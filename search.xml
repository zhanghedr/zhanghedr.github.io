<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Maven小结]]></title>
      <url>http://www.zhanghedr.com/2018/05/21/Maven%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Apache Maven基于POM(Project Object Model)文件，主要用于Java工程管理，极大简化了工程的构建过程，并标准化。</p>
<a id="more"></a>
<h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>POM文件主要元素：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>project</td>
<td>根元素</td>
</tr>
<tr>
<td>modelVersion</td>
<td>POM对象模型版本</td>
</tr>
<tr>
<td>groupId</td>
<td>组织或部门的项目</td>
</tr>
<tr>
<td>artifactId</td>
<td>项目下的maven项目，唯一标识</td>
</tr>
<tr>
<td>version</td>
<td>maven项目版本</td>
</tr>
<tr>
<td>packaging</td>
<td>打包方式，jar、war、 pom等</td>
</tr>
<tr>
<td>name</td>
<td>maven项目名称</td>
</tr>
<tr>
<td>description</td>
<td>maven项目描述</td>
</tr>
</tbody>
</table>
<h1 id="依赖机制"><a href="#依赖机制" class="headerlink" title="依赖机制"></a>依赖机制</h1><h3 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h3><p>项目中直接依赖的jar包，一般也会依赖很多其他的jar包，那么maven会把这种间接依赖引入，作为传递性依赖。</p>
<h3 id="依赖优先级"><a href="#依赖优先级" class="headerlink" title="依赖优先级"></a>依赖优先级</h3><p>多层级依赖情况下，很可能出现依赖冲突，maven会保证只有一个版本在存在，这时maven会依次按照2个原则引入依赖：</p>
<ol>
<li>最短路径原则：依赖层级路径最短的jar包会被引入到项目中</li>
<li>第一声明者优先：如果路径长短一样，那么看其本身或上级依赖的声明顺序，也就是从上到下的代码顺序</li>
</ol>
<h3 id="优化依赖"><a href="#优化依赖" class="headerlink" title="优化依赖"></a>优化依赖</h3><ul>
<li><code>mvn dependency:list</code>，可以查看项目中已解析依赖</li>
<li><code>mvn dependency:tree</code>，形成树状依赖结构，更直观，比如使用<code>mvn dependency:tree | grep SNAPSHOT</code>来查看所有快照版本</li>
<li><code>mvn dependency:analyze</code>，用于分析项目中依赖存在的问题<ul>
<li>Used undeclared dependencies found，未声明但使用的依赖，未显示声明而使用的传递性依赖，如果某个传递性依赖被删除则使用版本可能变化，有潜在风险，最好显示声明保证第一优先级</li>
<li>Unused declared dependencies found，声明但未使用的依赖，这种依赖大概率可以删除，但需要进一步看该依赖被其他依赖使用到，以及删除带来的风险</li>
</ul>
</li>
</ul>
<h1 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h1><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>一个项目经常会有多个模块，而根目录也经常会有parent模块的pom文件，聚合了module1、module2、module3等，同时每个子模块声明parent模块，这样就可以一次构建多个模块，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhanghedr.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webserver-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">module</span>&gt;</span>webserver-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">module</span>&gt;</span>webserver-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;<span class="name">module</span>&gt;</span>webserver-dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">module</span>&gt;</span>webserver-util<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>多个模块可以继承parent模块的依赖配置，通过<code>&lt;dependencies&gt;</code>和<code>&lt;dependencyManagement&gt;</code>元素实现，<code>&lt;dependencies&gt;</code>会使所有子模块都继承jar包，而<code>&lt;dependencyManagement&gt;</code>更加灵活，子模块不需要指定版本来引入依赖管理元素中指定好的依赖，子模块通过声明来选择继承自己需要的哪些依赖。</p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>Maven分为本地仓库和远程仓库，Maven会先在本地仓库查找依赖，如果本地没有或更新版本，会去远程仓库下载到本地使用。</p>
<ul>
<li>本地仓库是项目本地jar包仓库</li>
<li>远程仓库包括多个公开和私有的仓库</li>
</ul>
<h1 id="构件版本"><a href="#构件版本" class="headerlink" title="构件版本"></a>构件版本</h1><ul>
<li>RELEASE，稳定发布版本，不可覆盖，用于发布时</li>
<li>SNAPSHOT，快照版本，可以覆盖，也可以引用其中某个日期发布的快照版本，只应用于内部或开发时</li>
</ul>
<h1 id="Maven执行"><a href="#Maven执行" class="headerlink" title="Maven执行"></a>Maven执行</h1><ul>
<li><code>mvn clean</code>，清除target</li>
<li><code>mvn compile</code>，编译至target</li>
<li><code>mvn test</code>，执行test目录下的单元测试</li>
<li><code>mvn package</code>，按照打包方式打包，输出对应的包至target</li>
<li><code>mvn install</code>，按照打好的包安装至本地库中使用</li>
<li><code>mvn -U clean install</code>，强制更新依赖，比如SNAPSHOT</li>
<li><code>mvn deploy</code>，上传至私服</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>现在各种IDE有很多针对POM分析的工具可以使用，比如IDEA的Maven -&gt; Show Dependencies，可以看到依赖关系节点图，搜索要找的依赖。</p>
<ul>
<li>依赖冲突，<code>mvn dependency:tree</code>或IDEA等工具找到冲突依赖exclude掉，保留下想要的版本</li>
<li>升级依赖，存在一定风险，有可能依赖方删减了代码直接报错；依赖修改了实现；依赖Java版本升级发布环境低不支持调用报错，得经过充分测试</li>
<li>删减依赖，如果项目和各依赖都没有使用到，可以删除；如果项目未使用但有依赖使用到了，导致该已解析依赖版本变化，带来风险</li>
</ul>
<p>applicationContext.xml引入依赖包配置文件，有时需要引入jar包里的bean配置来完成调用，因为这些文件不会被自动加载到spring中，需要手动通过<code>&lt;import resource=&quot;classpath*:spring/*.xml&quot;/&gt;</code>加载，classpath后加*代表加载所有匹配的文件，不加则加载遇到的第一个文件，这样会带来风险：</p>
<ul>
<li>bean重名问题，可以将依赖配置bean名字根据项目取</li>
<li>可能载入多个同路径同名文件，导致更多bean重名问题</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[名词解释笔记]]></title>
      <url>http://www.zhanghedr.com/2018/05/14/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>如题</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:left">名词</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SPU</td>
<td style="text-align:left">Standard Product Unit，标准产品单位，如iPhone X</td>
</tr>
<tr>
<td style="text-align:left">SKU</td>
<td style="text-align:left">Stock Keeping Unit，库存量单位，如iPhone X 金色</td>
</tr>
<tr>
<td style="text-align:left">DAU</td>
<td style="text-align:left">Daily Active User，日活</td>
</tr>
<tr>
<td style="text-align:left">MAU</td>
<td style="text-align:left">Monthly Active User，月活</td>
</tr>
<tr>
<td style="text-align:left">PV</td>
<td style="text-align:left">Page View，页面浏览量</td>
</tr>
<tr>
<td style="text-align:left">UV</td>
<td style="text-align:left">Unique Visitor在一定时间内独立IP访问用户数</td>
</tr>
<tr>
<td style="text-align:left">CTR</td>
<td style="text-align:left">Click-Through Rate，点击率 = 点击UV / 曝光UV</td>
</tr>
<tr>
<td style="text-align:left">购买转化率 / 访购率</td>
<td style="text-align:left">访问到购买转化率 = 下单用户数 / 曝光意向UV</td>
</tr>
<tr>
<td style="text-align:left">跳出率</td>
<td style="text-align:left">Bounce Rate = 访问一个页面后就离开网站UV / 总UV</td>
</tr>
<tr>
<td style="text-align:left">GMV</td>
<td style="text-align:left">Gross Merchandise Volume，成交总金额，指下单金额，含付款和未付款</td>
</tr>
<tr>
<td style="text-align:left">KA</td>
<td style="text-align:left">Key Account，重要或者关键客户</td>
</tr>
<tr>
<td style="text-align:left">UUID</td>
<td style="text-align:left">Universally Unique Identifier，唯一识别码</td>
</tr>
<tr>
<td style="text-align:left">MOM</td>
<td style="text-align:left">Month-on-Month Ratio，环比， 环比增长率 = (今年5月 - 今年4月) / 今年4月</td>
</tr>
<tr>
<td style="text-align:left">YOY</td>
<td style="text-align:left">Year-on-Year Ratio，同比，同比增长率 = (今年5月 - 去年5月) / 去年5月</td>
</tr>
<tr>
<td style="text-align:left">———</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">B端</td>
<td style="text-align:left">Business，商家端</td>
</tr>
<tr>
<td style="text-align:left">C端</td>
<td style="text-align:left">Consumer，消费者端</td>
</tr>
<tr>
<td style="text-align:left">BD</td>
<td style="text-align:left">Business Development，公司业务拓展、商务开发的一线市场推广人员</td>
</tr>
<tr>
<td style="text-align:left">BDM</td>
<td style="text-align:left">Business Development Manager，BD经理，联络点负责人</td>
</tr>
<tr>
<td style="text-align:left">CM</td>
<td style="text-align:left">City Manager，城市经理，城市负责人</td>
</tr>
<tr>
<td style="text-align:left">DM</td>
<td style="text-align:left">District Manager，区域经理，区域负责人</td>
</tr>
<tr>
<td style="text-align:left">SRE</td>
<td style="text-align:left">Site Reliability Engineer，网站可靠性工程师，运维 + 部分架构</td>
</tr>
<tr>
<td style="text-align:left">PM</td>
<td style="text-align:left">Product Manager，产品经理</td>
</tr>
<tr>
<td style="text-align:left">UI</td>
<td style="text-align:left">User Interface， 偏向视觉设计</td>
</tr>
<tr>
<td style="text-align:left">UX / UE</td>
<td style="text-align:left">User Experience，偏向交互设计</td>
</tr>
<tr>
<td style="text-align:left">PRD</td>
<td style="text-align:left">Product Requirement Document，产品需求文档</td>
</tr>
<tr>
<td style="text-align:left">POI</td>
<td style="text-align:left">Point of Interest，产生利益的点，比如商家</td>
</tr>
<tr>
<td style="text-align:left">KPI</td>
<td style="text-align:left">Key Performance Indicator，关键绩效指标法，考核指标围绕关键成果领域进行选取</td>
</tr>
<tr>
<td style="text-align:left">IP</td>
<td style="text-align:left">Intellectual Property，知识产权</td>
</tr>
<tr>
<td style="text-align:left">SEO</td>
<td style="text-align:left">Search Engine Optimization，搜索引擎优化，指的是利用搜索引擎的规则来提高目前网站在搜索引擎内的排名</td>
</tr>
<tr>
<td style="text-align:left">SMART原则</td>
<td style="text-align:left">制定目标原则，S=Specific(具体)、M=Measurable(可衡量)、A=Attainable(可实现)、R=Relevant(相关性)、T=Time-Bound(有期限)</td>
</tr>
<tr>
<td style="text-align:left">STAR原则</td>
<td style="text-align:left">描述工作原则，Situation（情景）、Task（任务）、Action（行动）、Result（结果）</td>
</tr>
<tr>
<td style="text-align:left">SOP</td>
<td style="text-align:left">Standard Operating Procedure，标准作业程序， 基于实践总结将某一事件的标准操作步骤以统一的格式描述出来，用来指导和规范日常工作。比如上线规范、事故处理规范、开发流程规范</td>
</tr>
<tr>
<td style="text-align:left">埋点</td>
<td style="text-align:left">为了采集业务数据做的技术工作</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[AWS S3托管静态网站]]></title>
      <url>http://www.zhanghedr.com/2017/04/11/aws-s3-static-site/</url>
      <content type="html"><![CDATA[<p>AWS S3云存储不但可以放文件，还可以托管静态网站，当然GitHub是个不错的选择，这里讲下简单几步将静态网站部署到S3上。</p>
<a id="more"></a>
<p>假设域名是www.example.com，步骤如下：</p>
<ol>
<li>创建一个<strong>S3 bucket</strong>，名字必须和域名一样</li>
<li>上传静态网站内容到<strong>bucket</strong></li>
<li>设置里开启静态网站hosting</li>
<li>设置<strong>index</strong>页面</li>
<li>添加公共访问许可<strong>bucket policy</strong>，以JSON格式如下</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</div><div class="line">  <span class="attr">"Statement"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"Sid"</span>: <span class="string">"PublicReadGetObject"</span>,</div><div class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</div><div class="line">      <span class="attr">"Principal"</span>: <span class="string">"*"</span>,</div><div class="line">      <span class="attr">"Action"</span>: [</div><div class="line">        <span class="string">"s3:GetObject"</span></div><div class="line">      ],</div><div class="line">      <span class="attr">"Resource"</span>: [</div><div class="line">        <span class="string">"arn:aws:s3:::www.example.com/*"</span></div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建FTP]]></title>
      <url>http://www.zhanghedr.com/2017/04/11/ftp-setup/</url>
      <content type="html"><![CDATA[<p>FTP应用协议可以用于服务器文件的上传和下载，这里讲下如何在Ubuntu下搭建FTP。</p>
<a id="more"></a>
<p>FTP服务器工具有很多，这里选用<strong>vsftpd</strong>，安装如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install vsftpd</div></pre></td></tr></table></figure>
<p>然后修改配置并重启服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/vsftpd.conf</div><div class="line"></div><div class="line">write_enable=YES</div><div class="line">chroot_local_user=YES</div><div class="line">pasv_enable=YES</div><div class="line">pasv_min_port=1024</div><div class="line">pasv_max_port=1048</div><div class="line">pasv_address=&#123;Elastic IP&#125;</div><div class="line">allow_writeable_chroot=YES</div><div class="line"></div><div class="line">sudo service vsftpd restart</div></pre></td></tr></table></figure>
<p>创建FTP用户，adduser会配置好/home/ftp_user和user group：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo adduser ftp_user</div></pre></td></tr></table></figure>
<p>修改FTP用户home目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo usermod ftp_user <span class="_">-d</span> /home/ftp_user/</div></pre></td></tr></table></figure>
<p>查看user和group：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compgen –u</div><div class="line">compgen –g</div></pre></td></tr></table></figure>
<p>查看group包含哪些users：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getent group ftp_user</div></pre></td></tr></table></figure>
<p>看user属于哪些group：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groups ftp_user</div></pre></td></tr></table></figure>
<p>登录FTP：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftp &#123;domain&#125;</div></pre></td></tr></table></figure>
<p><code>/etc/vsftpd/ftpusers</code>列举了被禁止的FTP用户。</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[AWS EC2和RDS搭建基础环境]]></title>
      <url>http://www.zhanghedr.com/2017/04/10/aws-ec2-rds/</url>
      <content type="html"><![CDATA[<p>本文用EC2和RDS搭建简单的服务器环境，就当是Linux笔记了。</p>
<a id="more"></a>
<h3 id="创建EC2实例"><a href="#创建EC2实例" class="headerlink" title="创建EC2实例"></a>创建EC2实例</h3><p>首先在AWS上创建一个EC2实例，选用Ubuntu 16.04，测试的话可以选免费的t2.micro类型，在创建时注意选择或创建security group，同时在最后选择或创建一个key pair(public key+private key)，用来SSH登录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -i <span class="string">"/path/to/pem"</span> ubuntu@&#123;domain&#125;</div></pre></td></tr></table></figure>
<h3 id="创建RDS实例"><a href="#创建RDS实例" class="headerlink" title="创建RDS实例"></a>创建RDS实例</h3><p>创建MySQL RDS实例很简单，主要就是根据需求选类型、磁盘SSD、大小、Multi-AZ等，可以根据AWS提供的计算器根据使用量计算每个月价格。会给一个超级管理员用户，然后创建自定义DB用户。</p>
<h3 id="配置Security-Group"><a href="#配置Security-Group" class="headerlink" title="配置Security Group"></a>配置Security Group</h3><p>EC2需要配置inbound规则，也就是访问允许的协议、端口和IP，最基本几个配置举例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Protocol</th>
<th style="text-align:left">Port Range</th>
<th style="text-align:left">Source</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HTTP</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">80</td>
<td style="text-align:left">0.0.0.0/0</td>
</tr>
<tr>
<td style="text-align:left">HTTPS</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">443</td>
<td style="text-align:left">0.0.0.0/0</td>
</tr>
<tr>
<td style="text-align:left">SSH</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">22</td>
<td style="text-align:left">0.0.0.0/0</td>
</tr>
<tr>
<td style="text-align:left">Custom TCP Rule</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">8080 (customized)</td>
<td style="text-align:left">0.0.0.0/0</td>
</tr>
<tr>
<td style="text-align:left">Custom UDP Rule</td>
<td style="text-align:left">UDP</td>
<td style="text-align:left">8081 (customized)</td>
<td style="text-align:left">0.0.0.0/0</td>
</tr>
</tbody>
</table>
<p><code>0.0.0.0/0</code>表示任意IP地址，source可以是唯一的IP也可以是一个security group下的所有实例。RDS实例也需要设置inbound规则，首先是允许EC2所在的security group访问，然后可以是指定custom的IP地址。</p>
<h3 id="创建Elastic-IP"><a href="#创建Elastic-IP" class="headerlink" title="创建Elastic IP"></a>创建Elastic IP</h3><p>EC2实例的IPv4公共IP是动态的，每次重启都会改变，这里需要创建一个固定的Elastic IP，然后分配给EC2实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AWS -&gt; Elastic IPs -&gt; Allocate New Address -&gt; Associate Address</div></pre></td></tr></table></figure>
<h3 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h3><p>AWS同时提供domain代理服务，可以通过route 53注册域名，方便在上面配置DNS A/CNAME记录等，已有域名的忽略。</p>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>OpenJDK Java 7：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:openjdk-r/ppa <span class="comment"># if in Ubuntu 16.04</span></div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install openjdk-7-jdk</div></pre></td></tr></table></figure>
<p>Oracle Java 8:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:webbupd8team/java</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install oracle-java8-installer</div></pre></td></tr></table></figure>
<p>Java版本选择：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-alternatives --config java</div></pre></td></tr></table></figure>
<p>Tomcat 7:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install tomcat7</div><div class="line">sudo apt-get install tomcat7-docs tomcat7-admin tomcat7-examples <span class="comment"># 如果需要</span></div></pre></td></tr></table></figure>
<p>Nginx 1.10.0:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure>
<p>Tomcat配置文件在<code>/var/lib/tomcat7/conf</code>下，在server.xml里可以配置端口、HTTP相关；Nginx配置文件在<code>/etc/nginx</code>下，nginx.conf可以配置反向代理、负载均衡、动静分离等，这篇文章不讨论具体服务器配置问题。</p>
<h3 id="系统时区"><a href="#系统时区" class="headerlink" title="系统时区"></a>系统时区</h3><p>阿里云默认没记错应该是中国标准时间CST，AWS是UTC，Cron任务是根据系统时间走的，通过下面配置系统时区：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo dpkg-reconfigure tzdata</div><div class="line">date</div></pre></td></tr></table></figure>
<h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>AWS提供UI监控各项指标，还可以设定监控报警，自己也可以在Ubuntu下安装htop实时监控：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install htop</div><div class="line">htop</div></pre></td></tr></table></figure>
<p>htop包括了对多核CPU的百分比使用，内存百分比占用，和各进程的占用比。</p>
<h3 id="系统扩展"><a href="#系统扩展" class="headerlink" title="系统扩展"></a>系统扩展</h3><p>t2.micro肯定不够用的，EC2可以直接垂直升级到功能更好的机器，当然单机永远有局限，创建多个实例水平扩展又是一个大内容了。</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[网络传输协议]]></title>
      <url>http://www.zhanghedr.com/2017/04/01/internet-communication-protocol/</url>
      <content type="html"><![CDATA[<p>Web中接触最多的就是HTTP协议，但还有一些底层协议，按层高到低排列举例：</p>
<ul>
<li><strong>应用层 (Application)</strong>：HTTP、TLS/SSL、SSH、FTP</li>
<li><strong>传输层 (Transport)</strong>：TCP、UDP</li>
<li><strong>网络层 (Internet)</strong>：IP (IPv4, IPv6)</li>
<li><strong>链接层 (Link)</strong>：IEEE 802.11‎ </li>
</ul>
<a id="more"></a>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP主要负责寻址和数据包的传输</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP实现了在IP层之上可靠、有序、准确的传输数据包，因为太广泛的应用也常说TCP/IP，相反UDP不可靠但速度快。TCP传输建立需要三次握手，关闭需要四次握手，如下图所示：</p>
<p><img src="/img/internet_communication_protocol/tcp.jpg" alt="tcp"></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP经过多年已经有多个版本了1.0, 1.1, 2.0，包含HTTP方法、URI、HTTP版本、header、body、status code等。HTTP是无状态的，通过request和response交互，必须是客户端请求服务端，而不能反过来，服务端是被动的。新的Websocket协议解决这个问题，服务端可以主动的响应客户端了。</p>
<p>而HTTPS是基于TLS/SSL协议的HTTP，数据经过了加密且传输的两方身份经过了验证，大大提高了HTTP的安全性。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket本身不是协议，而是TCP/UDP传输协议的实现接口API，用于两个节点建立和关闭连接、发送和接收数据。</p>
<h3 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h3><p>HTTP是基于TCP传输通信的，首先TCP打开一个连接，然后HTTP在其中发送请求和接收响应，结束后TCP关闭连接，这是一个TCP短连接。一个页面有很多动态和静态资源请求，每次建立和关闭会消耗很多资源和时间，HTTP 1.0通过在响应头的<code>Connection: keep-alive</code>建立长连接，但HTTP 1.1已经默认所有连接都是长连接了，在一个HTTP请求完成后连接不会关闭，后续的请求可以继续用这个连接直到timeout，这样不会产生过多连接减少负担，当然长连接也需要消耗服务器一定资源去管理和维持。</p>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>对于时间敏感的通讯应用，在访问不高的情况下简单用JS写一个Ajax循环轮询请求即可，但其实很多请求是无效浪费的。对于访问量大的应用，可以用长轮询方式，客户端向服务器发送Ajax请求，server会挂起请求监测是否有消息，有新消息或超时才返回响应关闭连接，这样减少了无用的请求。</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Session 和 Cookie]]></title>
      <url>http://www.zhanghedr.com/2017/03/29/session-and-cookie/</url>
      <content type="html"><![CDATA[<p>Session是抽象概念，而cookie是实现会话最常用的方式，cookie保存在客户端而session保存在服务端，因为HTTP的无状态性，可以用cookie来记录前后请求的状态，session就是典型的例子，又或者如购物车，也可以用来记录用户偏好、行为分析等。</p>
<a id="more"></a>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie通过Server返回HTTP响应头设置比如：</p>
<p><code>Set-Cookie: wd=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=-1490916428; path=/; domain=.facebook.com</code></p>
<p>然后浏览器在接下来发送请求时会在header中带上cookies比如：</p>
<p><code>Cookie: theme=light; sessionToken=abc123</code></p>
<p>如果用户浏览器禁用cookie，可以在请求时把cookie放到HTTP URL或POST body中。不同子域名或端口可以共享Cookie。</p>
<h3 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h3><p>下面是facebook登录页面chrome显示的cookies：</p>
<p><img src="/img/session_and_cookie/facebook.jpg" alt="facebook"></p>
<p>可以看到分别有以下属性：</p>
<ul>
<li>Name / Value</li>
<li>Domain / Path</li>
<li>Expires / Max-Age</li>
<li>Size</li>
<li>HTTP</li>
<li>Secure</li>
<li>SameSite</li>
</ul>
<h3 id="Cookie分类"><a href="#Cookie分类" class="headerlink" title="Cookie分类"></a>Cookie分类</h3><p>下面是常见Cookie分类：</p>
<ul>
<li><code>Session cookie</code> 未设置过期时间的cookie，浏览器关闭后就被删除了，在<code>Expires / Max-Age</code>属性中为<code>Session</code>。</li>
<li><code>Persistent cookie</code> 设置了过期时间的cookie，在浏览器关闭后依然保存，在<code>Expires / Max-Age</code>属性中可以看到过期时间，到期删除或用户手动删除。用于跟踪多个请求的状态，比如session。</li>
<li><code>Secure cookie</code> 只能在HTTPS加密协议下传输，即上图属性<code>Secure</code>打钩的cookie。</li>
<li><code>HttpOnly cookie</code> 不能被前端JS访问，即上图属性<code>HTTP</code>打钩的cookie。</li>
<li><code>SameSite cookie</code> 只能在same site的情况下发送，即上图属性<code>SameSite</code>打钩的cookie。</li>
</ul>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>HTTP是无状态协议，也就是说在用户登录后的HTTP请求不知道之前登录过没有，在登录时可以在cookie中保存一个server产生的无规律字符串session_id，同时把session对象保存在服务端，然后根据session_id=session这种key-value获取会话，在服务端有下面几种保存方式：</p>
<ul>
<li>本地内存</li>
<li>数据库</li>
<li>文件</li>
<li>缓存服务器 (Redis)</li>
</ul>
<p>一般默认采用本地内存或数据库保存，常理来说本地内存肯定访问最快，但是在集群情况下session就不能共享了，而数据库和文件虽然可以持久化不丢失并且可以让服务器共享，但I/O效率较低；Redis缓存服务器则既满足了session共享同时效率也高，不过基于内存也存在数据丢失问题。可以考虑在DAL用MySQL和Redis，在登录时同步两者的session，redis设置过期时间，然后后面的请求只用redis，最终登出同步清除session。</p>
<p>Session对象包含了用户信息，如user_id、expire_time、last_activity等，这样每次请求server都可以用中间件或装饰器，通过cookie中的session_id得到session从而验证用户身份和信息。比如可以在某站登录后手动删除浏览器cookie，再刷新页面会被logout。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank" rel="external">https://en.wikipedia.org/wiki/HTTP_cookie</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies</a></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP Caching]]></title>
      <url>http://www.zhanghedr.com/2017/03/20/http-caching/</url>
      <content type="html"><![CDATA[<p>缓存是Web重要的组成部分，从浏览器开始到数据库的整个流程里，可以使用多种不同的缓存方案，本文主要是整理和学习Google开发者文章<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="external">HTTP Caching</a>的内容，讲一下基于HTTP/1.1的浏览器缓存，本文所有图片均引自于这篇文章。</p>
<a id="more"></a>
<p>浏览器是用户Web入口，大家知道刷新或者后退一个页面时响应很快，这是因为浏览器使用了本地磁盘的缓存资源，避免了去网站服务器GET请求和重新下载资源，这样减少了延迟也节省了流量，对js/css/img等静态资源进行尽可能长时间的合理cache，能大大提高网站性能。浏览器通过web server响应的HTTP headers决定缓存策略，缓存主要由以下几个headers控制：</p>
<ul>
<li><code>Cache-Control</code> 用于控制cache作用范围、条件和持续时间</li>
<li><code>ETag</code> 在cache过期后用于检验资源是否更新的token，通常是文件hash值</li>
<li><code>Expires</code> GMT格式的cache过期时间</li>
</ul>
<p>其中<code>Cache-Control</code>和<code>ETag</code>开始于HTTP/1.1，提供了更加全面优先级更高的缓存控制，用于接替之前类似<code>Expires</code>的headers，其中<code>Cache-Control: max-age</code>描述cache持续时间。这样就可以理解为：</p>
<p><code>Expires = now() + Cache-Control.max-age</code>，下面是<code>Cache-Control</code>的几种常见属性：</p>
<ul>
<li><strong>max-age</strong>: 缓存持续时间，单位秒 </li>
<li><strong>public</strong>: 允许被浏览器和中介cache</li>
<li><strong>private</strong>: 浏览器可以cache，但中介不能，如CDN</li>
<li><strong>no-cache</strong>: 浏览器每次都必须请求server通过Etag检查资源是否改变了，如果没变则使用本地副本，保证使用最新资源，同时利用cache避免重复下载</li>
<li><strong>no-store</strong>: 禁止浏览器和任何中介缓存cache副本</li>
</ul>
<p>根据上面的属性Google总结了下面这个decision tree：</p>
<p><img src="/img/http_caching/decision_tree.png" alt=""></p>
<p>那么接下来会发生下面几种情况：</p>
<h3 id="本地Cache未过期"><a href="#本地Cache未过期" class="headerlink" title="本地Cache未过期"></a>本地Cache未过期</h3><p>这无疑是最佳情况，因为浏览器甚至都不用访问server，直接调用本地磁盘副本就行了，减少了延迟也节省了流量。下图所示，GET文件缓存120秒，在cache还未过期时会返回<code>200 OK (from disk cache)</code>。</p>
<p><img src="/img/http_caching/cache_control.png" alt=""></p>
<h3 id="本地Cache过期后的ETag重新验证"><a href="#本地Cache过期后的ETag重新验证" class="headerlink" title="本地Cache过期后的ETag重新验证"></a>本地Cache过期后的ETag重新验证</h3><p>下图所示，假设120秒过期后又发出了同样的请求，浏览器先查看Cache-Control和Expires发现本地副本已过期，这时会提供<code>If-None-Match: {ETag}</code>的header请求server校验最新的文件<code>ETag</code>值，如果相同则返回<code>304 Not Modified</code>告诉浏览器本地副本可以继续使用120秒。这里虽然存在一个请求响应往返过程，但不需要重新下载文件节省了流量，而且续了浏览器cache周期。</p>
<p><img src="/img/http_caching/etag.png" alt=""></p>
<h3 id="本地Cache未过期但想强制用户使用最新版"><a href="#本地Cache未过期但想强制用户使用最新版" class="headerlink" title="本地Cache未过期但想强制用户使用最新版"></a>本地Cache未过期但想强制用户使用最新版</h3><p>有时候cache的js/css还没过期，但是此时前端dev有一个很重要的更新想让用户马上使用，肯定不可能说让用户去清除浏览器缓存，这时候需要改变资源的URL让用户强制下载新资源，比如加入版本号签名到文件名中style.<strong>x234dff</strong>.css。</p>
<p><img src="/img/http_caching/cache_hierarchy.png" alt=""></p>
<p>上图可以看到HTML文件是no-cache的，代表每次都必须去server查看是否有变动，而css文件缓存有效期1年，如果引用的css的URL(文件名)改变了，那么新的css版本和HTML会重新下载。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据HTTP缓存可以总结以下几点：</p>
<ul>
<li>根据资源更新频率不同设置不同的max-age，通常在1个星期以上，不常更新的文件(如library)可以直接设为1年</li>
<li>保持URL稳定，如果同一个资源使用了不同的URL，将会被多次下载和保存</li>
<li>保证服务器提供ETag，用于重新验证过期的缓存</li>
<li>让public的文件同时缓存于CDN以减少延迟</li>
</ul>
<p>Google有个<a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="external">PageSpeed Insights</a>可以对网站性能打分，并提供相关优化建议，大家可以试一下。至于如何配置web server(如Nginx/Apache)静态文件缓存，设置响应header，可以网上搜索有很多教程。</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[MD5 / SHA-1 + Salt]]></title>
      <url>http://www.zhanghedr.com/2017/03/19/md5-sha1-salt/</url>
      <content type="html"><![CDATA[<p>前面一篇博客谈到了hash函数，MD5和SHA-1也是其著名应用之一，他们被广泛应用于互联网的密码、文件、数据、HTTPS数字证书签名等校验中，但近年来陆续被证明可碰撞性被认为不再安全，<a href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html" target="_blank" rel="external">2017年Google宣布攻破了SHA-1算法</a>，Google从实际行动上提醒大家SHA-1不再安全，本文谈一下MD5/SHA-1和他们加盐(Salt)后在密码校验中的应用。</p>
<a id="more"></a>
<h3 id="MD5和SHA-1"><a href="#MD5和SHA-1" class="headerlink" title="MD5和SHA-1"></a>MD5和SHA-1</h3><p>MD5输出128位，SHA-1输出160位，SHA-1是基于MD5研发的，他们最重要的应用之一就是文件校验。比如下载软件会告诉你一个MD5哈希值，下载后你可以用<code>md5sum</code>监测其MD5值是否和网站给的值相同，用以监测文件的完整性，因为只要任意改动文件一处，那么MD5值就完全不同。</p>
<p>但是Google宣布他们找到了两个SHA-1值相同的PDF文件，实现了碰撞，那么也就是说攻击者有可能用hash值相同的恶意文件冒充原文件，SHA-1在互联网上有那么多的应用该怎么办呢，甚至包括了HTTPS数字证书签名、GIT/SVN等。不过SHA-1也不是谁都能破解的，也就是Google这么强大的计算能力才做到了，普通黑客破解的成本太大，但是为了避免以后潜在的安全漏洞，Google推荐使用更加安全的SHA-256算法。</p>
<h3 id="MD5-SHA-1-Salt密码校验"><a href="#MD5-SHA-1-Salt密码校验" class="headerlink" title="MD5/SHA-1 + Salt密码校验"></a>MD5/SHA-1 + Salt密码校验</h3><p>下面列了几种密码存储方式：</p>
<ol>
<li>raw_password</li>
<li>hash(raw_password)</li>
<li>hash(raw_password + salt)</li>
<li>more_hash(hash(raw_password + salt))</li>
</ol>
<p>hash/more_hash函数可以是MD5、SHA-1、SHA-256甚至是你自己定义的算法，上面四种方法可以说安全性依次递增，首先第一种明文保存密码不用说肯定是不可取的，但是<a href="http://www.williamlong.info/archives/2933.html" target="_blank" rel="external">CSDN当年就泄露了明文保存的密码</a>。</p>
<p>其次第二种只是简单映射了明文密码，黑客如果拿到了数据库，那么可以用彩虹表快速找出其中所有弱密码的用户，这也是相当不安全的。</p>
<p>第三种是一般常用的方法，也是相对安全的方法，这里的salt对于每个用户都是随机值，这样保证了即使两个密码一样的用户其hash值也不一样。这样黑客即使拿到了数据库里的<code>hash_password</code>和<code>salt</code>，也没法通过一个弱密码的<code>hash(raw_password + salt)</code>值找到所有账户配对，而是需要穷举各种弱密码+salt的hash值来配对某一个用户，如果网站保证了所有用户密码的复杂度(非123456/password/生日等)，那么用穷举法破解还是比较困难的。当然要注意这里的salt必须是随机不同的，不能是固定值，要不然就跟方法二没有区别了。</p>
<p>第四种方法就是第三种的增强版，可以用一些MD5/SHA-1的迭代或者SHA-256，甚至自定义hash函数，这样让黑客也没法直接按照rainbow table查找了，本质上是一样的，但是增加了一些破解成本。</p>
<p>总结就是要做到绝对安全很难，加密和破解技术是并行发展的，为了自己的账户安全，还是尽量用复杂的密码。现在网络上隐私泄露越来越严重，加上经常曝光的网站泄露账户事件，个人认为可以用两个复杂的密码，一个用于你认为比较重要的网站上，另外一个用于不重要或者你认为不可靠的网站上，这样如果他们的数据库泄露也不会影响到自己其他重要网站的账户安全。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.sina.com.cn/s/blog_77e8d1350100wfc7.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_77e8d1350100wfc7.html</a></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hash 与 HashMap]]></title>
      <url>http://www.zhanghedr.com/2017/03/18/hash-and-hashmap/</url>
      <content type="html"><![CDATA[<p>Hash函数在软件领域有非常多的应用， 最熟悉的莫过于HashMap，这里主要讲一下hash函数特性和Java中HashMap原理，同时比较下HashMap和Hashtable区别。</p>
<a id="more"></a>
<h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><p>Hash(散列)函数将任何长度的数据映射成固定长度的数据，是不可逆的。其最重要的特征是<strong>防碰撞能力</strong>，即对任意两个不同的数据输入，其输出hash值相同的概率非常小，近似为零，所以想用brute-force找出一个与某数据hash值相同的数据是非常困难的 。并且对于输入数据稍微改动一位，其hash值就会改动很大。贴一段Java 8中hashCode源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hash;</div><div class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">char</span> val[] = value;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</div><div class="line">            h = <span class="number">31</span> * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap作为hash函数的经典应用和Java最常用的数据结构之一，其实现非常有学习意义，这里以<strong>Java 7源码</strong>为例，注意Java 8里改动提升了很多且使用了tree，下面的某些地方可能不太适用。首先看一下HashMap的时间复杂度，其中n为entry的个数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th>Average</th>
<th>Worst</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Search</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td style="text-align:left">Insert</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td style="text-align:left">Delete</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>HashMap最著名的就是其平均O(1)的时间复杂度，这正是利用了hash函数的特性，HashMap是一个buckets(table)数组，index是key的hash值，对于不同的object产生不同的hash值快速锁定其index，而不需要遍历比较。而每个bucket是一个entry的单向链表(非ArrayList和LinkedList)，数组每个元素即为链表head，至于为什么桶里是一个链表而不是单个entry是因为hash函数存在碰撞可能，hash碰撞后还需要通过equals()判断然后放在同一个桶里，理想情况是entry均匀的分布在各个桶里。理论上确实存在最坏情况O(n)，如果用一个所有对象都生成一个hash值的hash函数，那么只会有一个桶即一个链表保存所有entry。</p>
<p>首先看一下链表node(entry)的结构和hash函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    <span class="keyword">int</span> hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (useAltHashing) &#123;</div><div class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line">        h = hashSeed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后下面是查找相关的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>getEntry(Object key)</code>这里面首先通过key的hash值找到table的index，然后通过head遍历链表直到找到key equals的entry为止，<code>get(Object key)</code>和<code>containsKey(Object key)</code>基本就是基于这个函数实现的。</p>
<p>然后就是<code>put(K key, V value)</code>，实现和getEntry大同小异，主要区别就是先遍历链表查找有没有相同的key，如果有替换并返回，如果没有则插入链表head新的entry，主要的两个方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里同时实现了insert，接下来就剩delete了，remove操作和上面类似，区别是要查找并删除entry，删除entry需要前后两个指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    Entry&lt;K,V&gt; prev = table[i];</div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            modCount++;</div><div class="line">            size--;</div><div class="line">            <span class="keyword">if</span> (prev == e)</div><div class="line">                table[i] = next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                prev.next = next;</div><div class="line">            e.recordRemoval(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e;</div><div class="line">        e = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么从上面的源码来看，只要hash碰撞概率低，那么这些操作都是近似O(1)，事实上也确实如此，至于为什么bucket选择用单向链表，可以考虑单向链表的<code>Search/Insert/Delete</code>时间复杂度分别是<code>O(n)/O(1)/O(1)</code>，其空间复杂度为O(n)，综合来看是非常好的。</p>
<p>可以看出如果一个类如果作为HashMap的key，那么其hashCode()的实现防碰撞和速度就很重要了。并且key最好是不可变的对象，要不然修改了某个属性后可能就找不到了。注意如果在iterator创建后改变了collection结构，那么iterator会抛出<code>ConcurrentModificationException</code>异常。下面是其他几种常见map实现：</p>
<ul>
<li><strong>ConcurrentHashMap</strong>: 用于多线程的HashMap</li>
<li><strong>EnumMap</strong>: 用enum作为key的Map</li>
<li><strong>LinkedHashMap</strong>: 可预知迭代顺序的HashMap (可以用来实现LRU)</li>
<li><strong>TreeMap</strong>: 基于SortedMap接口，使用key的Comparable或者提供的Comparator排序</li>
</ul>
<p>如果对Java 8的HashMap优化感兴趣，可以参考美团的<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="external">文章</a>。</p>
<h3 id="HashMap-vs-Hashtable"><a href="#HashMap-vs-Hashtable" class="headerlink" title="HashMap vs Hashtable"></a>HashMap vs Hashtable</h3><p>不同点：</p>
<ol>
<li>HashMap不是synchronized，而HashTable是synchronized的，HashMap非线程安全，但在单线程程序有更好性能</li>
<li>HashMap允许1个null key和多个null value，而Hashtable都不允许</li>
<li>Hashtable继承Dictionary是遗留类不再使用，单线程用HashMap，如果多线程可以用ConcurrentHashMap</li>
<li>HashMap迭代器iterator是fail-fast，而Hashtable迭代器enumerator不是</li>
</ol>
<p>相同点：</p>
<ol>
<li>都基于hash实现</li>
<li>都实现了Map接口</li>
<li>都是无序</li>
<li>时间复杂度都是常数</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL JOIN 和 UNION]]></title>
      <url>http://www.zhanghedr.com/2017/03/15/sql-join-and-union/</url>
      <content type="html"><![CDATA[<p>SQL里的<code>JOIN</code>还是很常用的，但是其中还分多种类型有时候临时会搞混，搜集整理了一些资料，这里通过简单例子区分一下，顺带提下<code>UNION</code>。如果把<code>JOIN</code>当做是垂直拆分的反向过程，那么<code>UNION</code>就是水平拆分的反向过程。</p>
<a id="more"></a>
<h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><p>把两个表垂直合并，假设有左a和右b两个表，JOIN有以下几种类型：</p>
<ul>
<li><code>INNER JOIN</code> 返回两个表的交集</li>
<li><code>LEFT JOIN</code> 返回a表所有rows，和匹配上的b表rows</li>
<li><code>RIGHT JOIN</code> 返回b表所有rows，和匹配上的a表rows</li>
<li><code>FULL JOIN</code> 返回两个表的并集</li>
<li><code>CROSS JOIN</code> 返回两个表的乘集，如a和b表都是10条记录，那么结果是100条</li>
</ul>
<p>注意在MySQL中<code>INNER</code> <code>OUTER</code> <code>CROSS</code>都是被忽略的，<code>JOIN</code>在有<code>ON</code>条件时为<code>INNER JOIN</code>，在没条件时即是<code>CROSS JOIN</code>，而<code>OUTER</code>不需要写直接用<code>LEFT JOIN</code> <code>RIGHT JOIN</code> <code>FULL JOIN</code>就行了。</p>
<p>下图引用自<a href="https://www.w3schools.com/sql/sql_join_inner.asp" target="_blank" rel="external">w3schools</a>，代表INNER JOIN，也应该能明白其他方式的含义了。</p>
<p><img src="https://www.w3schools.com/sql/img_innerjoin.gif" alt=""></p>
<p>下面是两个表的结构：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">table a    table b</div><div class="line"></div><div class="line">id         id</div><div class="line"><span class="comment">------     ------</span></div><div class="line">1          3</div><div class="line">2          4</div><div class="line">3          5</div><div class="line">4          6</div></pre></td></tr></table></figure>
<p>INNER JOIN例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.id = b.id</div><div class="line"></div><div class="line"><span class="keyword">id</span>         <span class="keyword">id</span></div><div class="line"><span class="comment">------     ------</span></div><div class="line"><span class="number">3</span>          <span class="number">3</span></div><div class="line"><span class="number">4</span>          <span class="number">4</span></div></pre></td></tr></table></figure>
<p>LEFT JOIN例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.id = b.id</div><div class="line"></div><div class="line"><span class="keyword">id</span>         <span class="keyword">id</span></div><div class="line"><span class="comment">------     ------</span></div><div class="line"><span class="number">1</span>          <span class="literal">NULL</span></div><div class="line"><span class="number">2</span>          <span class="literal">NULL</span></div><div class="line"><span class="number">3</span>          <span class="number">3</span></div><div class="line"><span class="number">4</span>          <span class="number">4</span></div></pre></td></tr></table></figure>
<p>RIGHT JOIN例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.id = b.id</div><div class="line"></div><div class="line"><span class="keyword">id</span>         <span class="keyword">id</span></div><div class="line"><span class="comment">------     ------</span></div><div class="line"><span class="number">3</span>          <span class="number">3</span></div><div class="line"><span class="number">4</span>          <span class="number">4</span></div><div class="line"><span class="literal">NULL</span>       <span class="number">5</span></div><div class="line"><span class="literal">NULL</span>       <span class="number">6</span></div></pre></td></tr></table></figure>
<p>FULL JOIN例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">FULL</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.id = b.id</div><div class="line"></div><div class="line"><span class="keyword">id</span>         <span class="keyword">id</span></div><div class="line"><span class="comment">------     ------</span></div><div class="line"><span class="number">1</span>          <span class="literal">NULL</span></div><div class="line"><span class="number">2</span>          <span class="literal">NULL</span></div><div class="line"><span class="number">3</span>          <span class="number">3</span></div><div class="line"><span class="number">4</span>          <span class="number">4</span></div><div class="line"><span class="literal">NULL</span>       <span class="number">5</span></div><div class="line"><span class="literal">NULL</span>       <span class="number">6</span></div></pre></td></tr></table></figure>
<p>CROSS JOIN例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b</div><div class="line"></div><div class="line"><span class="keyword">id</span>         <span class="keyword">id</span></div><div class="line"><span class="comment">------     ------</span></div><div class="line"><span class="number">1</span>          <span class="number">3</span></div><div class="line"><span class="number">1</span>          <span class="number">4</span></div><div class="line"><span class="number">1</span>          <span class="number">5</span></div><div class="line"><span class="number">1</span>          <span class="number">6</span></div><div class="line"><span class="number">2</span>          <span class="number">3</span></div><div class="line"><span class="number">2</span>          <span class="number">4</span></div><div class="line"><span class="number">2</span>          <span class="number">5</span></div><div class="line"><span class="number">2</span>          <span class="number">6</span></div><div class="line"><span class="number">3</span>          <span class="number">3</span></div><div class="line"><span class="number">3</span>          <span class="number">4</span></div><div class="line"><span class="number">3</span>          <span class="number">5</span></div><div class="line"><span class="number">3</span>          <span class="number">6</span></div><div class="line"><span class="number">4</span>          <span class="number">3</span></div><div class="line"><span class="number">4</span>          <span class="number">4</span></div><div class="line"><span class="number">4</span>          <span class="number">5</span></div><div class="line"><span class="number">4</span>          <span class="number">6</span></div></pre></td></tr></table></figure>
<p>注意在实际使用中不要使用<code>*</code>，在JOIN匹配后如果一个表ON字段有重复，那么对应的表记录也会被重复，JOIN的条件ON字段一般是在索引上以保证速度，它会比subquery快，但是JOIN还是尽量少用。</p>
<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>把相似的字段水平合并，UNION返回唯一的结果，UNION ALL返回有重复的结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> a</div><div class="line"><span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> b</div><div class="line"></div><div class="line"><span class="keyword">id</span>         </div><div class="line"><span class="comment">------</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">6</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> a</div><div class="line"><span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> b</div><div class="line"></div><div class="line"><span class="keyword">id</span>         </div><div class="line"><span class="comment">------</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[N + 1 问题]]></title>
      <url>http://www.zhanghedr.com/2017/03/13/n-1-problem/</url>
      <content type="html"><![CDATA[<p>在数据库中经常会碰到不同表之间关联的问题，为了防止单表过大字段过多，通常会通过表id将两个表联系起来，可以是一对一或者一对多的关系。API中也经常需要调用到多个表的信息，用惯了ORM简洁的调用方式后，代码中可能会出现N + 1问题。</p>
<a id="more"></a>
<p>假设一个社区网站的信息流首页，要显示用户关注的最新帖子(thread)列表，在每个列表条目中要显示thread标题和作者username，那么N + 1问题就在于用ORM先读取了所有threads，然后根据thread表中的user_id在user表中循环找username如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">threads = Thread.objects.all().order_by(<span class="string">"-create_time"</span>)</div><div class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">    user = User.objects.get(id=thread.user_id)</div></pre></td></tr></table></figure>
<p>这里只是举例Django ORM简单伪代码，不包括条件查找和分页问题，某些ORM若执行类似上面的代码会产生如下SQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> title, user_id <span class="keyword">FROM</span> <span class="keyword">thread</span> <span class="keyword">WHERE</span> ...</div><div class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></div><div class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span></div><div class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span></div><div class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">4</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样会生成N + 1条SQL，N是threads个数，即使都是用索引读取，数据库机器造成的网络开销时间还是不可忽视的。有时还不止是2个表关联，比如列表项中可能还要显示thread的tags和最新回复内容，那么就可能是3N + 1了。但是如果考虑到缓存，这样N条读取粒度很小，在流量高峰期时缓存命中率会很高，具体节省的时间还是要看benchmark才行。</p>
<p>当然ORM也会给出一些解决办法，这个基于不同ORM而异。这里说下最直观的两种解决方法，首先是提取出threads的user_id set，然后用IN (set)去读取user表，就变成了总共2条SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> title, user_id <span class="keyword">FROM</span> <span class="keyword">thread</span> <span class="keyword">WHERE</span> ...</div><div class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ...)</div></pre></td></tr></table></figure>
<p>另外一种就是用JOIN了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> t.title, u.username <span class="keyword">FROM</span> <span class="keyword">thread</span> t</div><div class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">user</span> u <span class="keyword">ON</span> t.user_id = u.id</div><div class="line"><span class="keyword">WHERE</span> ...</div></pre></td></tr></table></figure>
<p>这样只有一条SQL，甚至可以JOIN更多的表，当然JOIN能不用尽量不用，会影响到性能。</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[REST 与 SOAP]]></title>
      <url>http://www.zhanghedr.com/2017/03/12/rest-and-soap/</url>
      <content type="html"><![CDATA[<p>REST、SOAP和RPC是最常见的Web Services，其中REST和SOAP都是基于HTTP通信，但有很多不同点，基于数据格式又可以分JSON和XML，随着互联网的发展REST变得越来越流行，本文主要讨论它们的特性和不同。</p>
<a id="more"></a>
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>REST的优点主要有以下四点：</p>
<ul>
<li>URL表示对应资源，一般只有名词没有动词。</li>
<li>使用标准HTTP方法(GET/POST/PUT/DELETE等)抽象化接口，对于同一资源无需自定义对其的增查删改方法。</li>
<li>Request和response的payload支持多种格式，常见的有<code>JSON</code>和<code>XML</code>，一般推荐用<code>JSON</code>。</li>
<li>可以根据HTTP Header缓存GET请求，注意保证GET不会改变状态。</li>
</ul>
<p>RESTful web services常见的框架有<a href="https://jersey.java.net/" target="_blank" rel="external">Jersey</a>和<a href="http://www.dropwizard.io/" target="_blank" rel="external">Dropwizard</a>。</p>
<h2 id="API-Root-URL"><a href="#API-Root-URL" class="headerlink" title="API Root URL"></a>API Root URL</h2><p>常用的URL是<code>https://api.example.com/v1</code>，其构成为：</p>
<ul>
<li>HTTPS协议保证数据安全</li>
<li>api subdomain独立出API URL</li>
<li>example.com网站域名</li>
<li>v1表示API版本，为了兼容老用户和新用户</li>
</ul>
<h2 id="URL资源"><a href="#URL资源" class="headerlink" title="URL资源"></a>URL资源</h2><p>URL中的资源是名词，HTTP方法代表对资源的动作，如果要请求的资源是用户，资源集可以用<code>/people</code>，单个资源用<code>/people/{username}</code>，根据不同的HTTP方法有：</p>
<ul>
<li><code>GET /people</code> : 获取和返回用户列表</li>
<li><code>POST /people</code> : 创建单个用户，返回新建用户</li>
<li><code>GET /people/{username}</code> : 获取和返回单个用户</li>
<li><code>PUT /people/{username}</code> : 更新单个用户，提供整个model属性，返回更新用户</li>
<li><code>PATCH /people/{username}</code>  : 更新单个用户，提供要更新的model属性，返回更新用户</li>
<li><code>DELETE /people/{username}</code> : 删除单个用户，返回空</li>
<li><code>GET /people/{username}/videos</code> : 获取和返回单个用户的视频列表</li>
</ul>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在获取资源列表的时候，如果符合条件的列表太大会对服务器造成很大压力，并且请求时间会很长，Pagination能很好解决这个问题，常用<code>LIMIT</code>对资源table限制resultset。</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>合理的状态码也是好的设计一部分，这里列举一些常见的，完整列表可以在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">RFC2616</a>查看。</p>
<ul>
<li><strong>200</strong> OK</li>
<li><strong>400</strong> Bad Request</li>
<li><strong>401</strong> Unauthorized</li>
<li><strong>403</strong> Forbidden</li>
<li><strong>404</strong> Not Found</li>
<li><strong>405</strong> Method Not Allowed</li>
<li><strong>500</strong> Internal Server Error</li>
<li><strong>503</strong> Service Unavailable</li>
</ul>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>如果是第三方API则需要授权才能使用，一般使用<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="external">OAuth 2.0</a>实现，很多框架都带OAuth工具包，具体步骤可以参见各大公司的API文档。如果是作为用户使用，需要先在公司开发平台注册一个key，作为使用其API的授权。</p>
<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content Type"></a>Content Type</h2><p>前面提到REST优点之一就是请求和响应payload支持多种格式，一般支持JSON，其次是XML，当然你也可以支持HTML/CSV等格式，对应不同的需求。</p>
<h2 id="HTTP-Request-Response"><a href="#HTTP-Request-Response" class="headerlink" title="HTTP Request Response"></a>HTTP Request Response</h2><p>简单POST请求创建用户例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST /v1/people HTTP/1.1</div><div class="line">Host: api.example.com</div><div class="line">Content-Type: application/json</div><div class="line">Accept: application/json</div><div class="line"> </div><div class="line">&#123;</div><div class="line">  <span class="string">"username"</span>: <span class="string">"zhanghedr"</span>,</div><div class="line">  <span class="string">"email"</span>: <span class="string">"example@gmail.com"</span>,</div><div class="line">  <span class="string">"bio"</span>: <span class="string">"Software Engineer"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Date: Sun, 12 Mar 2017 18:26:00 GMT</div><div class="line">Server: WSGIServer/0.2 CPython/3.5.3</div><div class="line">Content-Length: 24</div><div class="line"> </div><div class="line">&#123;</div><div class="line">  <span class="string">"id"</span>: 52,</div><div class="line">  <span class="string">"username"</span>: <span class="string">"zhanghedr"</span>,</div><div class="line">  <span class="string">"email"</span>: <span class="string">"example@gmail.com"</span>,</div><div class="line">  <span class="string">"bio"</span>: <span class="string">"Software Engineer"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​      </p>
<h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>前面提到REST的优点也就是SOAP的缺点，SOAP主要特性有以下四点：</p>
<ul>
<li>URL不表示对应资源，不同的资源请求URL是相同的。</li>
<li>所有的请求都通过HTTP POST实现。</li>
<li>请求的资源和操作方法定义在POST payload SOAP message中，需要解析才能知道。</li>
<li>只支持XML数据格式，在很多场景有局限性。</li>
</ul>
<p>SOAP web services常见框架有<a href="http://cxf.apache.org/" target="_blank" rel="external">Apache CXF</a>和<a href="http://axis.apache.org/axis2/java/core/" target="_blank" rel="external">Apache Axis2</a>。</p>
<h2 id="SOAP-Message"><a href="#SOAP-Message" class="headerlink" title="SOAP Message"></a>SOAP Message</h2><p>因为SOAP所有的请求全部定义在其XML message中，所以其结构和内容显得格外重要，它主要由三部分构成：</p>
<ul>
<li>Envelope，XML root，必填</li>
<li>Header，头信息，可不填</li>
<li>Body，请求资源、方法和变量，必填</li>
</ul>
<p>下面是请求的一个例子，响应也是类似结构返回对应请求XML。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></div><div class="line">    <span class="attr">xmlns:soap</span>=<span class="string">"http://www.w3.org/2003/05/soap-envelope/"</span> <span class="attr">soap:encodingStyle</span>=<span class="string">"http://www.w3.org/2003/05/soap-encoding"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">soap:Body</span> <span class="attr">xmlns:m</span>=<span class="string">"http://www.example.org/abc"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">m:getUserById</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">m:id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m:id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">m:getUserById</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到getUserById方法被定义在了SOAP message中，而URL<code>https://api.example.com/v1</code>没有包括任何信息，可以使用这一个ROOT URL通过不同的message实现所有API功能，这种不灵活的方式造成了SOAP在互联网中越来越少的应用。</p>
<h2 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h2><p>WSDL全称Web Services Description Language，是基于XML的语言，用于描述SOAP的功能，通过WSDL可以在Web Services中直接调用对象，而不用手动组成SOAP message。</p>
<p>​          </p>
<h1 id="Web-Services-vs-API"><a href="#Web-Services-vs-API" class="headerlink" title="Web Services vs API"></a>Web Services vs API</h1><p>这两个概念容易搞混，API是软件接口，可以是本地接口也可以是基于网络的接口；而Web Services是API的一种，是基于网络的接口。</p>
<p>比如Google Map API分别提供了Android、iOS和Web Services接口，前两个是基于平台的库API，而Web Services是基于网络的REST API。</p>
<p>​         </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://bourgeois.me/rest/" target="_blank" rel="external">https://bourgeois.me/rest/</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/webservices/0907_rest_soap/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/webservices/0907_rest_soap/</a></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Cache写机制]]></title>
      <url>http://www.zhanghedr.com/2017/03/08/cache-writing-policies/</url>
      <content type="html"><![CDATA[<p>Cache的写机制有两种，分别是<code>Write Through</code>和<code>Write Back</code>，一般指硬件磁盘读写，但也可用于软件cache实现，比如DAL。</p>
<a id="more"></a>
<h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>在写的时候，同时更新cache和磁盘，这里可以理解为cache和数据库，这样数据库和缓存内容始终保持一致，这种方式实现简单一致性好，但效率一般。下流程图说明了这个过程，图片引用自<a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="external">wikipedia</a>)。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/04/Write-through_with_no-write-allocation.svg" alt=""></p>
<h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>也称作write-behind，在写的时候只写cache而延后写数据库，从而减少数据库的I/O而获得更好的性能。在延后写数据库之后这个cache标记为dirty，然后有两种情况，第一种是这个cache过期或LRU被踢掉了，那么它在invalidate时必须将它的最新内容写回到数据库中，保证数据一致；第二种情况是这个cache被新的写操作给替换了，这时可以选择继续延后写数据库，而始终保持cache内容最新，如果在更新非常频繁的内容上，可以在这部分cache延迟写多个周期后，再同步到数据库里。</p>
<p>这种方法效率更高，但实现复杂，而且存在cache和数据库不一致问题，如果系统宕机可能造成数据丢失。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c2/Write-back_with_write-allocation.svg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[理解与优化MySQL索引]]></title>
      <url>http://www.zhanghedr.com/2017/03/04/mysql-index/</url>
      <content type="html"><![CDATA[<p>索引<code>index(key)</code>是最常见的MySQL速度优化方法之一，大部分数据库和文件系统都采用<a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="external">B-tree</a>和<a href="https://en.wikipedia.org/wiki/B%2B_tree" target="_blank" rel="external">B+tree</a>作为索引数据结构，简略来说使带有索引的查找时间复杂度为<code>O(logn)</code>，而避免了全表扫描<code>O(n)</code>，在数据量大的表中速度可以提升几个数量级，本文粗略的学习和探讨MySQL索引原理、数据结构与优化。</p>
<a id="more"></a>
<h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>索引是为了高效的查询数据，就像是一本字典通过目录快速找到对应的页，这样自然会想到binary search、binary search tree等，但索引也很大存在磁盘上，磁盘I/O消耗比内存要大得多，在查找时必须首先考虑减少磁盘I/O次数，同时优化时间复杂度，同时还不能忽略对写造成的影响，这样就需要具体考虑计算机存储原理来选择数据结构了。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>下面分别是wikipedia中的<a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="external">B-tree</a>和<a href="https://en.wikipedia.org/wiki/B%2B_tree" target="_blank" rel="external">B+tree</a>结构图：</p>
<p><img src="/img/mysql_index/b-tree.png" alt="b-tree"></p>
<p><img src="/img/mysql_index/b+tree.png" alt="b-tree"></p>
<p>B-tree和B+tree不同于<code>self-balancing binary search trees</code>在于：</p>
<ul>
<li>每个node中包含m个数据项</li>
<li>每个node可以有m+1个指针和children</li>
<li>一个node中的数据项按key递增排序</li>
<li>每个指针对应的子节点数据项介于指针两边数据项之间</li>
</ul>
<p>这样不同于一般的BST它的高度会非常低且展开会非常大，下面会谈到为什么这样会利于减少磁盘I/O，而MySQL又用B+tree作为索引数据结构，可以看到B+tree的不同点在于：</p>
<ul>
<li>数据只保存在叶节点上，这样必须遍历树高度才能完成查找</li>
<li>所有的相邻叶节点增加了指针，从而方便的访问范围数据</li>
</ul>
<p>可以看到对于每个节点只要用递归二分法查找即可，如果没找到就到对应指针的子节点递归，直到找到key或者没到到为null为止。BTREE每次访问节点消耗一次磁盘I/O而非每个数据项消耗一次，这样树高度越低越好，如果总数据项为N，每个节点的数据项为m，树高为h，那么<code>O(h) = O(log(m+1)N)</code>，这里m越大则高度越低，每一个节点看做一个page，而<code>m = page_size / data_size</code>，可以看到我们想在一个节点里放多的数据项，就要减少数据项的大小，也就是为什么要缩减字段大小原因，比如能用tinyint就不用int。这里因为B+tree非叶节点不包含真正数据只有key，也节省了空间增大了扇出拥有更好的性能。</p>
<h3 id="引擎实现"><a href="#引擎实现" class="headerlink" title="引擎实现"></a>引擎实现</h3><p>MySQL有两种引擎MyISAM和InnoDB，MyISAM不支持binary log用的比较少，InnoDB对于每个table都需要一个主键，最好是自增的int主键，占空间小，且递增顺序在b+tree中逐一插入新数据，效率比较高。下图是张洋博客里的插图，非常清晰的描绘了InnoDB存储结构：</p>
<p><img src="/img/mysql_index/innodb.png" alt="innodb"></p>
<p>所有的数据都在叶节点上，主键对应了完整的row数据，这样根据主键的查找效率非常高，但其他索引的数据项中只存储对应主键，这样其他索引需要先找到主键再搜索一次找到对应的数据。</p>
<h3 id="索引使用与优化"><a href="#索引使用与优化" class="headerlink" title="索引使用与优化"></a>索引使用与优化</h3><p>MySQL索引包括<code>PRIMARY KEY</code> <code>INDEX</code> <code>UNIQUE INDEX</code>，索引又分单列索引和多列索引两种，许多人的误区是把所有查询的字段都单独加上索引就行了，首先过多的索引会占用很多空间，表对索引大小有限制，其次索引会影响写速度，INSERT/DELETE到索引字段都需要b+tree改动结构。</p>
<p>多列索引有一个<strong>最左前缀原理</strong>，3个column的索引<code>(col1, col2, col3)</code>，只会命中这三种搜索条件组合<code>(col1)</code> <code>(col1, col2)</code> <code>(col1, col2, col3)</code>，和部分命中 <code>(col1, col3)</code> 。</p>
<p>如何建索引应该结合业务来定，找出所有的表SQL或瓶颈SQL，进行<code>EXPLAIN</code>分析索引使用情况。下面主要讨论多列索引，假设有一个app.post表，记录了帖子的所有回复，这个表中有一个多列索引<code>key (thread_id, user_id, status)</code>，首先看表index：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> app.post;</div></pre></td></tr></table></figure>
<p>因为测试过类似表就直接写结果了，<code>EXPLAIN</code>的结果类似如下，<code>key_len</code>代表应用到的索引字段大小，type=ALL代表全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| id | select_type | table | type  | possible_keys | key  | key_len | ref               | rows | Extra |</div><div class="line">+<span class="comment">----+-------------+-------+-------+---------------+------+---------+-------------------+------+-------+</span></div><div class="line">|  1 | SIMPLE      | post  | const | key           | key  | 8       | const,const,const | 1    |       |</div></pre></td></tr></table></figure>
<p>下面根据完整的多列索引查询，<code>key_len</code>会应用到所有三个字段，并且打乱WHERE顺序也是如此，因为MySQL根据索引对顺序进行了优化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> thread_id=<span class="number">512</span> <span class="keyword">AND</span> user_id=<span class="number">12</span> <span class="keyword">AND</span> <span class="keyword">status</span>=<span class="number">0</span>;</div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> user_id=<span class="number">12</span> <span class="keyword">AND</span> <span class="keyword">status</span>=<span class="number">0</span> <span class="keyword">AND</span> thread_id=<span class="number">512</span>;</div></pre></td></tr></table></figure>
<p>如果只用前两个索引，会用到前两个索引字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> thread_id=<span class="number">512</span> <span class="keyword">AND</span> user_id=<span class="number">12</span>;</div></pre></td></tr></table></figure>
<p>如果只用第一和第三个，则只会用到第一个索引字段，因为缺失了第二个字段，会对thread_id找到的结果进行扫描查找status：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> thread_id=<span class="number">512</span> <span class="keyword">AND</span> <span class="keyword">status</span>=<span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>如果只用后两个将用不到索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> user_id=<span class="number">12</span> <span class="keyword">AND</span> <span class="keyword">status</span>=<span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>如果分别使用，只有thread_id会用到索引，而user_id和status用不到：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> thread_id=<span class="number">512</span>;</div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> user_id=<span class="number">12</span>;</div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app.post <span class="keyword">WHERE</span> <span class="keyword">status</span>=<span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>总结如下：</p>
<ul>
<li>多列索引最左前缀原则</li>
<li>索引不仅对SELECT有效，对UPDATE/DELETE同样有效</li>
<li>索引对于<code>ORDER BY</code>和<code>GROUP BY</code>在一定情况下有效</li>
<li>索引对于模糊、范围查找有效，包括&lt; &gt; BETWEEN IN AND OR LIKE等</li>
<li>索引对于函数表达式无效，比如MONTH(date)，这个容易忽略</li>
<li>索引对于小表作用不大</li>
<li>索引不适合主要为写操作的表</li>
<li>索引对于选择性<code>COUNT(DISTINCT(field))/COUNT(*)</code>小的字段效率较低</li>
<li>索引非越多越好，会减慢写入速度</li>
<li>每个字段用尽可能小的类型大小</li>
<li>在字段过长的情况下，可以用前缀索引</li>
</ul>
<p>如理解有误的地方欢迎指正。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>张洋的博客 - <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p>
<p>美团博客 - <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">http://tech.meituan.com/mysql-index.html</a></p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[网络安全浅谈]]></title>
      <url>http://www.zhanghedr.com/2017/02/08/csrf-and-api-test/</url>
      <content type="html"><![CDATA[<p>CSRF (Cross-site request forgery)、XSS (Cross-site scripting)和SQL注入是几个最著名的网络攻击，这里主要讲一下CSRF原理和如何在API测试中实现CSRF验证，也简单说明下XSS和SQL注入。</p>
<a id="more"></a>
<h2 id="Same-origin-policy"><a href="#Same-origin-policy" class="headerlink" title="Same-origin policy"></a>Same-origin policy</h2><p>首先得说说互联网安全基础<code>Same-origin policy</code>，指不同的origin不能通过script访问，这里的origin包括了protocol、domain和port，这个规则保护了用户不会被未知网站的script攻击，比如说CSRF如下。但JS需要访问不同server有这两个方法：</p>
<ul>
<li>Web server采用反向代理服务器如Nginx，这样JS的请求都通过反向代理分发到了后台多个服务器了</li>
<li>使用<strong>Cross-origin resource sharing</strong> (<strong>CORS</strong>)规定，服务器响应添加头<code>Access-Control-Allow-Origin</code>和其他相关的方法设置，允许指定的domain跨站访问，比如说主站，但如果为<code>*</code>则是公开资源</li>
</ul>
<p>比如facebook的POST请求<a href="https://www.facebook.com/ajax/bz" target="_blank" rel="external">https://www.facebook.com/ajax/bz</a> 返回的响应头限制了只有主站的JS可以访问，不能跨域访问：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">access-control-allow-origin</span>: https://www.facebook.com</div></pre></td></tr></table></figure>
<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>简单来说CSRF就是攻击者欺骗用户访问某个危险网站B，由于<code>Same-origin policy</code>B站JS不能直接请求安全网站A，但如果是GET则简单的点击或者通过图片src加载就会上当，如果是POST则需要模仿表单提交，以用户的名义发送请求给A。如果用户最近登录过网站A还没有登出session cookie还在的话，那么这个用户未授权请求就会成功，而且还是在用户和网站A都不知情的情况下，攻击者可以模仿用户的身份对其进行一些改变状态的操作，这是很危险的，所以网站A需要有CSRF的防御机制，下面以Django举例。</p>
<p>Django内置了CSRF验证机制，Cookie-to-Header Token方法：</p>
<ol>
<li>用户登录后，除了session cookie，Django还会产生一个随机的<code>csrftoken</code> cookie</li>
<li>在隐藏表单、HTTP header或POST body中也加入这个token，在Django中可以设<code>X-CSRFToken={csrftoken}</code>的header</li>
<li>Server验证cookie和header中两个token的值是否一致</li>
</ol>
<p>使用了这种token验证的防御机制后，如果用户不小心点击了攻击者的链接，虽然他能利用网站A还存有的session验证用户身份，但是发出的请求只有cookie token而没有header token，服务器CSRF验证失败将会返回403 Forbidden错误。</p>
<p>根据<a href="https://tools.ietf.org/html/rfc7231.html#section-4.2.1" target="_blank" rel="external">RFC 7231#section-4.2.1</a>，安全的请求是只读、无危害的如GET，后端应该合理的实现GET请求，而对不安全的请求如POST/PUT/DELETE进行保护。</p>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS核心是在HTML页面注入恶意JS代码，假设在回复栏里输入恶意JS并且贴到HTML被浏览，比如<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，又或者是引用另外一个js src，会在页面打开时执行，也就是说跳过了<code>Same-origin policy</code>跨站执行了JS，JS可以做很多事，比如窃取用户的cookie。</p>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入和XSS理论上类似，也是通过给恶意输入，让server执行错误的SQL语句，比如夹杂着注释的参数。所以对用户输入必须进行严格校验。</p>
<h2 id="API测试验证CSRF"><a href="#API测试验证CSRF" class="headerlink" title="API测试验证CSRF"></a>API测试验证CSRF</h2><p>这里以Django和<a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en" target="_blank" rel="external">Postman</a>举例，Postman是一款很方便的HTTP API测试Chrome插件。</p>
<ol>
<li><p>安装<a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo?hl=en" target="_blank" rel="external">Postman Interceptor</a>插件，使Postman可以共享浏览器cookie，从而更方便测试，安装完成后在Postman右上角开启interceptor，这样就能看到浏览器中的cookies了</p>
</li>
<li><p>Postman右上角新建环境</p>
</li>
<li><p>新建login请求，并在test中加入下面script，获取CRSF cookie并且设置为postman环境变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> crsf_cookie = postman.getResponseCookie(<span class="string">"csrftoken"</span>);</div><div class="line">postman.setEnvironmentVariable(<span class="string">"csrf_token"</span>, crsf_cookie.value);</div></pre></td></tr></table></figure>
</li>
<li><p>新建要测试的POST请求，添加CRSF token header，比如django：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X-CSRFToken : &#123;&#123;csrf_token&#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>先发送login请求，然后发送要测试的POST请求</p>
</li>
</ol>
<p>这样POST请求就能自动抓取环境中的CSRF token作为其header发送出去验证了，无需每次都手动设置。</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Virtualenv使用指定Python版本]]></title>
      <url>http://www.zhanghedr.com/2017/02/04/virtualenv-with-given-python-version/</url>
      <content type="html"><![CDATA[<p>Virtualenv默认使用系统python版本，但在某些project我们想用另外一个版本的python，virtualenv在创建环境时可以选择已安装的python版本，但在某些情况下我们没有root权限，可以选择在用户本地安装一个python版本来创建环境。</p>
<a id="more"></a>
<h4 id="使用系统版本"><a href="#使用系统版本" class="headerlink" title="使用系统版本"></a>使用系统版本</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv -p /usr/<span class="built_in">local</span>/bin/python3 env</div></pre></td></tr></table></figure>
<h4 id="使用本地版本"><a href="#使用本地版本" class="headerlink" title="使用本地版本"></a>使用本地版本</h4><p>以Python 3.5.3举例，安装条件<a href="https://github.com/jkbrzt/httpie" target="_blank" rel="external">httpie</a>, <a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="external">virtualenv</a>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># install local python</span></div><div class="line"><span class="built_in">cd</span> ~ &amp;&amp; mkdir -p ~/.localpython/3.5.3</div><div class="line">http --download https://www.python.org/ftp/python/3.5.3/Python-3.5.3.tgz</div><div class="line">tar -zxvf Python-3.5.3.tgz</div><div class="line"><span class="built_in">cd</span> Python-3.5.3</div><div class="line">./configure --prefix=<span class="variable">$HOME</span>/.localpython/3.5.3</div><div class="line">make</div><div class="line">make install</div><div class="line"><span class="built_in">cd</span> ~ &amp;&amp; rm Python-3.5.3.tgz &amp;&amp; rm -rf Python-3.5.3</div><div class="line"></div><div class="line"><span class="comment"># create virtualenv with local python</span></div><div class="line"><span class="built_in">cd</span> /path/to/project</div><div class="line">virtualenv -p ~/.localpython/3.5.3/bin/python3.5 env</div><div class="line"><span class="built_in">source</span> env/bin/activate</div><div class="line">python --version</div><div class="line">deactivate</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac安装MySQL]]></title>
      <url>http://www.zhanghedr.com/2017/01/22/mac-install-mysql/</url>
      <content type="html"><![CDATA[<p>安装MySQL的方法很多，最好还是从官网下载，需要注意的是新版本的初始root密码改为随机生成了，这里讲下安装步骤和添加PATH。</p>
<a id="more"></a>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol>
<li><p>官网下载最新版<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">MySQL Community Server</a></p>
</li>
<li><p>打开安装包一直下一步，记下在安装过程中随机生成的初始root密码，在右侧Notifications里也会有密码提醒</p>
</li>
<li><p>安装完成后，添加mysql到PATH中，添加方法在下面有写</p>
</li>
<li><p>在<code>System Preferences -&gt; MySQL</code>中开启server，并且勾选开机自启动</p>
</li>
<li><p>打开你使用的terminal，<code>mysql -u root -p</code>，使用初始随机密码登录</p>
</li>
<li><p>初次登录后会提醒必须重置root密码才能使用，根据版本不同修改密码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'MyNewPass'</span>; <span class="comment"># MySQL 5.7.6+</span></div><div class="line">SET PASSWORD FOR <span class="string">'root'</span>@<span class="string">'localhost'</span> = PASSWORD(<span class="string">'MyNewPass'</span>); <span class="comment"># MySQL 5.7.5-</span></div><div class="line">FLUSH PRIVILEGES;  <span class="comment"># 最后刷新权限</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="添加PATH"><a href="#添加PATH" class="headerlink" title="添加PATH"></a>添加PATH</h1><p>方法如下，注意系统读取PATH时是按从左到右顺序优先级来的，所以把mysql放在末端。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>  <span class="comment"># 查看当前PATH，分隔符是':'</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/mysql/bin  <span class="comment"># 添加mysql到PATH末端</span></div></pre></td></tr></table></figure>
<p>但是上面的方法只是暂时作用于当前session，下次登录时添加的PATH就失效了，如果想永久添加，需要把这句话写到你使用的一个shell配置文件中，比如<code>~/.zshrc、~/.bashrc、~/.bash_profile、~/.profile</code>。最后要生效，只需重新读一遍配置文件<code>source ~/.zshrc</code>，要不然重启terminal也可以。</p>
<p>但是上面这个永久方法只是对于当前user有效，因为是在<code>/Users/username/</code>目录下配置，想要为所有users都添加PATH，需要把<code>/usr/local/mysql/bin</code>添加到下面文件中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/paths</div></pre></td></tr></table></figure>
<h1 id="MySQL客户端"><a href="#MySQL客户端" class="headerlink" title="MySQL客户端"></a>MySQL客户端</h1><p>这里推荐<a href="https://www.sequelpro.com/" target="_blank" rel="external">Sequel Pro</a>，非常简洁快速还是开源的，不过只支持MySQL一种数据库。这时候你就可以在上面建一个<code>127.0.0.1</code>数据库测试一下了，用root和之前修改过的密码。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[新Macbook Pro插上USB断网问题]]></title>
      <url>http://www.zhanghedr.com/2017/01/22/mac-network-issue/</url>
      <content type="html"><![CDATA[<p>最近想用移动硬盘给2016 Macbook Pro做备份来着，结果一插上就断网，一拔下来就连上了，原本用Type C转USB转换器已经很蛋疼了，还有这事就更无语了，搜了下发现原来是因为WIFI频段2.4GHz和USB 3.0冲突造成的。</p>
<a id="more"></a>
<p>解决方法大致有下面几种：</p>
<ul>
<li>听说官方转换器没有这个问题</li>
<li>换5GHz的双频路由器</li>
<li>试试别的Type C接口，把移动硬盘拿远点</li>
</ul>
<p>最简答的方法无疑就是第三种了，亲测确实换个口就连上网了，但还是不稳定，最终的方法我觉得还是第二种换个双频路由吧。</p>
<p>提一下最近发现一个奇怪的问题，似乎电脑和sqlite3有网络冲突，我用<a href="http://sqlitebrowser.org/" target="_blank" rel="external">DB Browser for SQLite</a>或者其他sqlite客户端时网就变得特别不稳定，在2.4G和5G环境下都会被严重影响甚至掉线，关闭后就立即恢复正常了，求问这是什么原因。</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac备份和移动硬盘读写格式]]></title>
      <url>http://www.zhanghedr.com/2017/01/22/mac-backup/</url>
      <content type="html"><![CDATA[<p>初入Mac都会遇到备份的问题，Windows有Ghost，Mac有自带的Time Machine，这里主要讲下用Time Machine备份和MAC使用移动硬盘读写格式的问题。</p>
<a id="more"></a>
<h1 id="Time-Machine备份"><a href="#Time-Machine备份" class="headerlink" title="Time Machine备份"></a>Time Machine备份</h1><p>因为Time Machine (TM)备份需要很大的空间，通常要是本体的2倍大小，而TM是增量备份，就像DB的transaction log，第一次备份很大，后面只对变化的文件进行备份就比较小了。它需要一个单独的磁盘进行备份，常用移动硬盘来备份，最好有1T以上。</p>
<p>首先搜索打开TM，可以选择排除不需要备份的大目录，比如Downloads、Steam什么的，然后选择磁盘，这里可以选移动硬盘或分区磁盘，就可以开始备份了。</p>
<p><img src="/img/mac_backup/time_machine.png" alt=""></p>
<p>下面问题来了，TM必须要求是Mac专用的硬盘格式才能备份，你可以买一个硬盘专门用来做TM备份，不过得转成MAC专用格式，而一般的移动硬盘都是NTFS格式的，在Win下使用没有问题，但是到了Mac下就是只读了不能写入文件，所以再谈一下MAC使用移动硬盘的问题。</p>
<h1 id="移动硬盘读写格式"><a href="#移动硬盘读写格式" class="headerlink" title="移动硬盘读写格式"></a>移动硬盘读写格式</h1><p>据大家介绍有以下几种方法解决：</p>
<ul>
<li>使用<a href="https://www.paragon-software.com/home/ntfs-mac/" target="_blank" rel="external">Paragon</a>或<a href="https://www.tuxera.com/products/tuxera-ntfs-for-mac/" target="_blank" rel="external">Tuxera</a>这种第三方付费NTFS插件读写</li>
<li>格式化成Exfat或Fat32格式双平台通用</li>
<li>硬盘分区分别用于Mac和Win</li>
<li>开启苹果自带的NTFS插件</li>
</ul>
<p>对于第二点，Fat32太老了所以不考虑，而Exfat据说兼容性很差有很多坑也不敢用。还有人写了开启苹果自带插件的教程<a href="http://www.tianwaihome.com/2014/07/mac-osx-ntfs.html" target="_blank" rel="external">http://www.tianwaihome.com/2014/07/mac-osx-ntfs.html</a> 大家可以看看，不过听说也有很多问题，总之NTFS是微软的东西，苹果下面使用问题多多，综合来说我觉得还是用第一个方案吧，虽然花点钱但是省心省时间。</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iCloud同步]]></title>
      <url>http://www.zhanghedr.com/2017/01/22/iCloud-sync/</url>
      <content type="html"><![CDATA[<p>一直以来都觉得iCloud和iTunes就是apple生态系统里的两个坑，用了这么多年了始终没太搞明白这两个怎么用，特别在照片同步上感觉很不方便。由于无法忍受iCloud最近在mac和iphone上反复提醒我5GB空间满了，目前又不想花钱升级，就清理下照片和设置同步。</p>
<a id="more"></a>
<h1 id="选择云盘"><a href="#选择云盘" class="headerlink" title="选择云盘"></a>选择云盘</h1><p>国外常见的有Google Drive, Dropbox, OneDrive iCloud Drive，国内常见的有百度云、微云、360云盘、坚果云等，由于一些不可描述的原因国内很多云盘都关闭了。我对云盘有三点需求：数据安全可靠、国内可直接访问、多平台方便同步，首先对于数据安全这点我更相信Google Drive, Dropbox等，然而国内还不能直接访问，OneDrive我不知道可不可以有没有人告知下。现在用Google Drive + iCloud，虽然iCloud做的不如前面几位，但考虑到现在用的都是苹果系产品，用它作文件同步还是不错的，免费只有5GB空间也是个梗，想想国内云盘、Google Drive什么的都是&gt;10GB的，5GB未免太小气了点。为了使用iCloud，首先必须设置下照片同步这个问题。</p>
<h1 id="在各设备上取消不必要iCloud同步项"><a href="#在各设备上取消不必要iCloud同步项" class="headerlink" title="在各设备上取消不必要iCloud同步项"></a>在各设备上取消不必要iCloud同步项</h1><p>首先在MAC上进入设置-&gt;iCloud，取消不需要的同步项，比如我不用额Safari还有占空间的Photos，注意在取消照片同步前，先把iCloud上的照片本地备份下，然后在管理中删除所有照片和取消照片同步，这样iCloud就有空间来做文档同步了。同样在iPhone上也在iCloud设置中取消不必要的同步项，包括照片。</p>
<p>除了照片以外，iPhone备份也是iCloud空间的大头，在手机上设置排除不需要备份的app，可以节省很多备份空间。</p>
<p>开启iCloud Drive同步，设置中添加Documents文件夹，我会把我重要的文档放在其中这样就能自动同步了。</p>
<h1 id="Image-Capture导入和删除照片"><a href="#Image-Capture导入和删除照片" class="headerlink" title="Image Capture导入和删除照片"></a>Image Capture导入和删除照片</h1><p>Image Capture可以用来导入iPhone照片和批量删除手机上的照片，导入的照片都会放在/Users/username/Pictures里，新iPhone照片多了动态图功能，这样很多照片都附带一个MOV格式视频，感觉挺占空间的，此外Photos也可以用来导入照片。</p>
<p>Image Capture批量删除手机照片有个坑，对于10.12 macOS，好像苹果取消了删除键..后来发现必须把mac和iphone的照片同步都关了才能看到删除键。</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Lambda表达式]]></title>
      <url>http://www.zhanghedr.com/2017/01/16/lambda-expression/</url>
      <content type="html"><![CDATA[<p>Lambda表达式指的是<strong>匿名函数</strong>，当你只需要运行一次或若干次一个不是很复杂的函数时，可以考虑使用lambda，它不需要名字还能减少代码量，并且可以作为一个变量传入到另一个函数中。这种函数源自functional programming languages，每种语言对于lambda的支持不尽相同，本文讲一下lambda在Java 8和Python 3中的基本用法。</p>
<a id="more"></a>
<h1 id="Java-8-Lambda-Expressions"><a href="#Java-8-Lambda-Expressions" class="headerlink" title="Java 8 Lambda Expressions"></a>Java 8 Lambda Expressions</h1><p>lambda是Java 8中的重要特性，这里举几个例子讲下基本用法。</p>
<p>Runnable用来创建thread时需要override run()方法，下面这个例子通过lambda一行就搞定了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// old runnable</span></div><div class="line">Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"normal runnable"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// lambda runnable</span></div><div class="line">Runnable r2 = () -&gt; System.out.println(<span class="string">"lambda runnable"</span>);</div><div class="line"></div><div class="line">r1.run();</div><div class="line">r2.run();</div><div class="line"></div><div class="line"><span class="comment">// or new lambda thread</span></div><div class="line"><span class="keyword">new</span> Thread(</div><div class="line">  () -&gt; System.out.println(<span class="string">"lambda new thread"</span>)</div><div class="line">).start();</div></pre></td></tr></table></figure>
<p>追溯到Runnable接口可以看到Java 8新增了@FunctionalInterface的注解，这样你在用第一种Runnable方法的时候IDE就会提示warning更换成lambda，而且如果你在@FunctionalInterface里有多个没覆盖的abstract方法，compiler就会报错了。</p>
<p>再看看下面这个Collections倒序例子，为了举例lambda使用Comparator而不使用reverse(list)，这里的Comparator也有@FunctionalInterface注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// old Comparator</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(arr);</div><div class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">System.out.println(list);</div><div class="line"></div><div class="line"><span class="comment">// lambda Comparator</span></div><div class="line">list = Arrays.asList(arr);</div><div class="line">Collections.sort(list, (Integer o1, Integer o2) -&gt; o2.compareTo(o1));</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure>
<p>下面这个是遍历例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="comment">// old iteration</span></div><div class="line"><span class="keyword">for</span> (Integer n : list)</div><div class="line">  System.out.println(n);</div><div class="line"></div><div class="line"><span class="comment">// new iteration</span></div><div class="line">list.forEach(n -&gt; System.out.println(n));</div></pre></td></tr></table></figure>
<p>Java 8新增了包java.util.stream和java.util.function，提供了map方法来处理传入Function、filter方法处理Predicate条件、reduce方法处理BinaryOperator，从而更方便的处理Collection数据，看下面的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="comment">// old iteration</span></div><div class="line"><span class="keyword">for</span> (Integer n : list)</div><div class="line">  System.out.println(n + <span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="comment">// lambda map</span></div><div class="line">list.stream().map((n) -&gt; n + <span class="number">10</span>).forEach(n -&gt; System.out.println(n));</div><div class="line"></div><div class="line"><span class="comment">// lambda map + filter</span></div><div class="line">list.stream().map((n) -&gt; n + <span class="number">10</span>).filter(n -&gt; n % <span class="number">3</span> == <span class="number">0</span>).forEach(n -&gt; System.out.println(n));</div><div class="line"></div><div class="line"><span class="comment">// lambda map + filter + reduce</span></div><div class="line"><span class="keyword">int</span> sum = list.stream().map((n) -&gt; n + <span class="number">10</span>).filter(n -&gt; n % <span class="number">3</span> == <span class="number">0</span>).reduce((a, b) -&gt; a + b).get();</div><div class="line">System.out.println(sum);</div></pre></td></tr></table></figure>
<p>可以看出新lambda特性很强大，让Java的代码更简洁更可读了，但毕竟是函数编程思想，还需要一定的适应时间。</p>
<h1 id="Python-3-Lambda-Expressions"><a href="#Python-3-Lambda-Expressions" class="headerlink" title="Python 3 Lambda Expressions"></a>Python 3 Lambda Expressions</h1><p>Python的语法比较灵活，其实在很多情况下不用lambda也能用很短的代码实现。注意在Python 3中对很多遍历iterable的方法进行了优化，返回的是iterator可以直接遍历，所以这里用到了list()，Python 2的话不需要加，下面针对map, filter和reduce举例。</p>
<p>首先是map计算加一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># function way</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n + <span class="number">1</span></div><div class="line">[plus(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>)]</div><div class="line"></div><div class="line"><span class="comment"># lambda way</span></div><div class="line">list(map(<span class="keyword">lambda</span> n : n + <span class="number">1</span>, range(<span class="number">3</span>)))</div><div class="line"></div><div class="line"><span class="comment"># list comprehension</span></div><div class="line">[n + <span class="number">1</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>)]</div></pre></td></tr></table></figure>
<p>然后是filter过滤掉奇数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># function way</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEven</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span></div><div class="line">list(filter(isEven, range(<span class="number">6</span>)))</div><div class="line"></div><div class="line"><span class="comment"># lambda way</span></div><div class="line">list(filter(<span class="keyword">lambda</span> n : n % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">6</span>)))</div><div class="line"></div><div class="line"><span class="comment"># list comprehension</span></div><div class="line">[n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>接着是reduce求和，注意Python 3中已经把reduce放到functools中了，不再是built-in方法，需要import。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"></div><div class="line"><span class="comment"># function way</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">reduce(sum, range(<span class="number">6</span>))</div><div class="line"></div><div class="line"><span class="comment"># lambda way</span></div><div class="line">reduce(<span class="keyword">lambda</span> a, b : a + b, range(<span class="number">6</span>))</div><div class="line"></div><div class="line"><span class="comment"># list comprehension</span></div><div class="line"><span class="comment"># reduce不推荐用这个方法</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[金融概念入门]]></title>
      <url>http://www.zhanghedr.com/2017/01/14/funding-ipo-market/</url>
      <content type="html"><![CDATA[<p><a href="http://tech.sina.com.cn/i/2017-01-12/doc-ifxzqnim4012858.shtml" target="_blank" rel="external">知乎宣布完成D轮1亿美元融资 今日资本领投</a></p>
<blockquote>
<p>知识平台知乎宣布今日完成 D 轮 1 亿美元融资，投资方为今日资本，包括腾讯、搜狗、赛富、启明、创新工场等在内的原有董事股东也全部跟投。据创新工场李开复透露，知乎该轮融资完成后估值超过10亿美元，迈入独角兽行列。</p>
</blockquote>
<a id="more"></a>
<h3 id="融资"><a href="#融资" class="headerlink" title="融资"></a>融资</h3><p>融资通俗的讲就是企业需要钱，根据轮数可以分为：<strong>种子轮 - 天使轮 - A轮 - B轮 - C轮 - D轮 - E/F/G等轮</strong>，一般随着轮数的增加，产品、企业规模、商业模式和融资金额都会增长。一般来说C轮后就可以上市，但也可能还没满足上市条件或者还不想上市而继续融资。此外，虽然有些到公司没有实现盈利，但是拥有大量用户和良好前景的公司也会获得大量融资，比如需要持续烧钱的Uber和滴滴。在<a href="https://www.crunchbase.com/organization/zhihu#/entity" target="_blank" rel="external">这里</a>可以查到知乎A-D轮融资的详情。</p>
<p>根据投资类别和一般对应论数又分为以下几种：</p>
<ul>
<li>天使 (Angel Invest): 种子/天使轮</li>
<li>VC (Venture Capital/风险投资): A/B轮</li>
<li>PE (Private Equity/私募股权融资): C/D轮</li>
</ul>
<h3 id="IPO和上市"><a href="#IPO和上市" class="headerlink" title="IPO和上市"></a>IPO和上市</h3><p>IPO (Initial Public Offering)就是股份公司<strong>首次公开募股</strong>，也就是首次公开发行股票，吸引投资者和募集资金。IPO的要求非常严格，而每个板块的IPO要求又不同，这在下面的股票板块中会讲到。</p>
<p>公司IPO之后就可以上市，上市就是通过证券交易所公开交易股票，比如在上海、深圳、香港、纽约等<strong>交易所</strong>公开交易股票。</p>
<p><strong>IPO和上市是两个过程但又是不可分割的</strong>，法律规定必须IPO之后才能上市。虽然上市可以募集资金和提高公司声望等，但要注意其有利有弊，不一定对于每个公司都是好的。</p>
<h3 id="融资、IPO、上市的区别"><a href="#融资、IPO、上市的区别" class="headerlink" title="融资、IPO、上市的区别"></a>融资、IPO、上市的区别</h3><p>这是三个不同的概念，首先融资的方式有很多种，可以银行贷款、企业发债、私募股权等，而IPO本身也是融资方式的一种。  一般的过程是融资之后上市，当然也可以选择融资但一直不上市，或者不融资就上市。而上市前面提到只是在证券交易所公开平台上交易股票。</p>
<h3 id="股票板块和类型"><a href="#股票板块和类型" class="headerlink" title="股票板块和类型"></a>股票板块和类型</h3><p>在不同板块上市的企业规模也有不同，股票根据板块可以分为<strong>主板、中小板、创业板、新三板</strong>，每个板块上市都有不同要求，比如主板/中小板/创业板对于发行股票数量都有要求，例如大于5000万发行股票，而创业板要求有技术创新的企业。如果没有达到IPO要求，可以考虑<strong>新三板挂牌</strong>，新三板门槛低但实际不是IPO，股票流动性低难交易。注意IPO的政策也在不断变化，以最新政策为准。</p>
<p>股票根据上市地点和投资者可以分为这些类型：<strong>A股、B股、H股、N股、S股</strong>等。比如A股是用人民币交易在中国境内上市针对国内的股票，B股是用人民币标值但只能用外币交易且在中国境内上市针对外国的外资股，而H股是注册在内地上市在香港的外资股。</p>
<h3 id="主要证券交易所"><a href="#主要证券交易所" class="headerlink" title="主要证券交易所"></a>主要证券交易所</h3><p><a href="https://wallstreetcn.com/articles/311729" target="_blank" rel="external">一张图看清全球60大证券交易所</a>提到，世界上主要的证券交易所有：</p>
<ul>
<li>亚太：上交所、深交所、港交所、日交所</li>
<li>美洲：纽交所(NYSE)、纳斯达克(NASDAQ)</li>
<li>欧洲：伦敦证交所、泛欧交易所</li>
</ul>
<p>纽交所上市的有阿里巴巴、360等，纳斯达克上市的有百度、京东、微博、谷歌、FB等，以往认为纽交所多为成熟大企业而纳斯达克多为高科技创业公司，但现在这种差异在拉小。</p>
<h3 id="股市指数"><a href="#股市指数" class="headerlink" title="股市指数"></a>股市指数</h3><p><a href="https://zhuanlan.zhihu.com/p/23726791" target="_blank" rel="external">股市指数</a>是指反映证券市场行情变化的股票价格指数，如道琼斯、标普500、纳斯达克。</p>
]]></content>
      
        <categories>
            
            <category> Finance </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[进程和线程的区别]]></title>
      <url>http://www.zhanghedr.com/2017/01/04/difference-between-process-and-thread/</url>
      <content type="html"><![CDATA[<p>进程(process)和线程(thread)是操作系统里最基本的概念之一，在算法题和工作上碰到这个问题，决定做一个总结。这里打个简单的比方，如果操作系统是一座工厂，CPU是生产机器，工厂里的调度员调度机器去生产某个产品，一个产品流水线是一个进程，每个流水线上的一个工人是一个线程。</p>
<ul>
<li>单进程单线程：一个工人在一个流水线上工作</li>
<li>单进程多线程：多个工人在一个流水线上工作</li>
<li>多进程单线程：多个流水线，每个有一个工人工作</li>
<li>多进程多线程：多个流水线，每个有多个工人工作</li>
</ul>
<a id="more"></a>
<h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程可以理解为一个程序，操作系统会分配CPU、内存等环境给要执行的进程，一个CPU同一时间只能执行一个进程，当这个进程执行完或它被分配的执行时间结束后，CPU就会执行下一个进程，如果它还没有执行完，那么CPU在之后再轮回到它时会从上一次结束的点继续执行。</p>
<p>现代电脑的CPU都很强大，电脑上不可能同一时间只能运行一个程序，操作系统会调度多进程运行多个程序从而充分利用CPU，比如我们同时打开了QQ、Chrome和Sublime就是三个进程。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>虽然进程实现了操作系统上多个程序的并发，但对于一个程序运行来说，以blocking的形式运行难免会出现问题，如果一个进程在某个点阻塞，如果它的阻塞不会影响后续的代码，那么我们完全可以提前运行后面的程序而不必等其阻塞恢复，我们希望在一个进程里有多个工人并发同时工作以进一步增加效率，这里的工人就是线程。比如Word有多个线程，一个线程负责输入，一个线程负责显示，还有线程负责自动保存，这让我们感觉到输入和显示同时发生。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li>一个操作系统可以包含多个进程，一个进程可以包含多个线程</li>
<li>多进程分别拥有不同的内存，而同一进程下的多个线程共享同一部分内存，因此线程之间可以读写同样的数据变量</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/hazir/archive/2011/05/09/2447287.html" target="_blank" rel="external">http://www.cnblogs.com/hazir/archive/2011/05/09/2447287.html</a></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[常见 Java 设计模式]]></title>
      <url>http://www.zhanghedr.com/2016/12/20/java-design-patterns/</url>
      <content type="html"><![CDATA[<p>设计模式（Design Patterns）是一套被反复使用、代码设计经验的总结。设计模式有很多原则，比如降低耦合、简单化类、接口隔离等，都是为了提高代码复用率、代码可读性和代码可靠性。当然其中一些模式可能到了其他语言里就失效了，比如python基于语言的特性某些设计模式会有其他的解决方法，但是学习这些模式肯定还是有帮助的，在现实中没必要刻意去套用模式，最终还是简洁有效的code最好。本文介绍常用Java设计模式以及代码实例。</p>
<a id="more"></a>
<p>​         </p>
<h1 id="Behavioral模式"><a href="#Behavioral模式" class="headerlink" title="Behavioral模式"></a>Behavioral模式</h1><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>设计对象一对多的依赖关系，当一个主对象改变状态时，它所有的观察者都会被通知并且更新。在使用时注意observer同为observable的链和thread safe。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>常见的有RSS feed，多个subscribers订阅一个RSS feed，当publisher有更新时所有的订阅者都会自动收到更新。又或者是UI里的button触发它所有的listeners更新。还有Java SE里的java.util.Observer和java.util.Observable。</p>
<h3 id="代码和结构图"><a href="#代码和结构图" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/observer" target="_blank" rel="external">代码</a>和结构图</h3><p>以publisher-&gt;subscribers为例子。<br><img src="/img/java_design_patterns/observer.png" alt=""></p>
<p>​      </p>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>提供一种实现好的方式来迭代一个集合和访问其中的元素，可以自己定义基于不同条件的迭代方式。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>当需要给一个集合提供一种标准化的迭代方式时，比如java.util.ArrayList和java.util.Scanner</p>
<h3 id="代码和结构图-1"><a href="#代码和结构图-1" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/iterator" target="_blank" rel="external">代码</a>和结构图</h3><p>实现了一个基本的iterator和一个基于group的iterator。<br><img src="/img/java_design_patterns/iterator.png" alt=""></p>
<p>​     </p>
<h2 id="strategy"><a href="#strategy" class="headerlink" title="strategy"></a>strategy</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>提供一个协议将算法封装起来，让client可以在runtime动态的选择执行某种算法。其封装思想和facade有点类似，但是strategy提供了选择哪个类执行的接口，而facade是将所有的类型都封装起来不在runtime改变。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>当有一个类下的多种算法需要动态选择去执行时，可以通过strategy模式将这个类封装起来，让client根据需求改变和执行其中一种算法。</p>
<h3 id="代码和结构图-2"><a href="#代码和结构图-2" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/strategy" target="_blank" rel="external">代码</a>和结构图</h3><p>用StrategySelector将Strategy封装，用contrustor或者setter来在runtime选择用哪个类的execute()方法。<br><img src="/img/java_design_patterns/strategy.png" alt=""></p>
<p>​     </p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>定义一个程序skeleton的算法，保证算法步骤结构不变，让子类继承重新定义其中的某些步骤来实现不同的算法。</p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>当有一个算法有固定的步骤时，某些步骤根据需求不同，可以让不同类继承这个类来重新定义其中某些步骤，从而重新定义了算法。</p>
<h3 id="代码和结构图-3"><a href="#代码和结构图-3" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/template" target="_blank" rel="external">代码</a>和结构图</h3><p>有一个strategy的模板，有两种类型的策略继承它，重定义其中的init(), calculate()和finish()，从而实现了不同的子策略算法。<br><img src="/img/java_design_patterns/template.png" alt=""></p>
<p>​     </p>
<h1 id="Creational模式"><a href="#Creational模式" class="headerlink" title="Creational模式"></a>Creational模式</h1><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>限制一个类在系统中只能创建一个对象。</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><p>当只需要一个对象时，比如abstract factory、builder模式中，还有java.lang.Runtime里实现了。</p>
<h3 id="代码和结构图-4"><a href="#代码和结构图-4" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/singleton" target="_blank" rel="external">代码</a>和结构图</h3><p>包含各种基本和完善的singleton实现。<br><img src="/img/java_design_patterns/singleton.png" alt=""></p>
<p>​     </p>
<h2 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>非常常见的创建对象模式，用于创建一个类型下的不同类对象。工厂类基于参数创建不同对象，将创建对象和client code隔离开来。</p>
<h3 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个类有很多子类时，让client创建对象时不需要知道其中的细节，比如java.util.Calendar。</p>
<h3 id="代码和结构图-5"><a href="#代码和结构图-5" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/factory" target="_blank" rel="external">代码</a>和结构图</h3><p>基于三种水果类创建的工厂模式。<br><img src="/img/java_design_patterns/factory.png" alt=""></p>
<p>​     </p>
<h2 id="abstract-factory"><a href="#abstract-factory" class="headerlink" title="abstract factory"></a>abstract factory</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>工厂的工厂，超级工厂用于创建子工厂来创建相关的类对象。</p>
<h3 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h3><p>当多个类相关联时，同时每个类下都有不同子类，用抽象工厂来创建不同工厂对应每条产品线，每个子工厂然后再创建对应产品线上的不同子类对象。同时client不知道创建对象的具体细节。</p>
<h3 id="代码和结构图-6"><a href="#代码和结构图-6" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/abstractfactory" target="_blank" rel="external">代码</a>和结构图</h3><p>假设厨房有食物和水果两个类，厨房1工厂创建披萨和蓝莓，厨房2工厂创建面条和苹果，从而实现了多个工厂对于不同产品线不同子类的创建。<br><img src="/img/java_design_patterns/abstractfactory.png" alt=""></p>
<p>​     </p>
<h2 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>用于创建复杂类对象，借助builder类来动态创建对象同时保证复杂类的不变性。</p>
<h3 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个复杂类有非常多变量时，不一定每个变量对于创建都是必须的，这时候不想对于每种组合可能性都给一个constructor，而又想保证其不变性，就可以借助builder来灵活的创建其对象，比如java.lang.StringBuilder。</p>
<h3 id="代码和结构图-7"><a href="#代码和结构图-7" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/builder" target="_blank" rel="external">代码</a>和结构图</h3><p>一个用户有非常多的属性，其中只有名字和邮箱是必须的，其他都是可选，而且保证User是final，这时用一个内置的UserBuilder类来动态set每一个optional变量，然后通过builder来创建User。<br><img src="/img/java_design_patterns/builder.png" alt=""></p>
<p>​     </p>
<h1 id="Structural模式"><a href="#Structural模式" class="headerlink" title="Structural模式"></a>Structural模式</h1><h2 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>用于在不改变已有类的基础上给其动态添加新功能实现功能扩展。</p>
<h3 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h3><p>在需要不改变类的基础上对其进行不同的功能扩展时，可以动态的对这种类添加不同的功能，而不需要继承多个类来实现不同的功能组合。例子有BufferedReader input = new BufferedReader(new InputStreamReader(System.in));</p>
<h3 id="代码和结构图-8"><a href="#代码和结构图-8" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/decorator" target="_blank" rel="external">代码</a>和结构图</h3><p>装饰器封装了User，然后对一个中国用户的属性进行描述，他可以是年轻或老，可以是男或女，这些额外属性描述的功能通过扩展装饰器来实现其单独的功能，然后我们就可以通过装饰器动态的给User添加不同的描述了。<br><img src="/img/java_design_patterns/decorator.png" alt=""></p>
<p>​     </p>
<h2 id="adapter"><a href="#adapter" class="headerlink" title="adapter"></a>adapter</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>就像其名字一样，用于将两个接口连接在一起让client使用。</p>
<h3 id="使用场景-9"><a href="#使用场景-9" class="headerlink" title="使用场景"></a>使用场景</h3><p>有些时候一个interface没法直接使用，可以通过adapter进行接口转换从而正常使用。比如java.util.Arrays#asList()将多个String通过Arrays转换成List。</p>
<h3 id="代码和结构图-9"><a href="#代码和结构图-9" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/adapter" target="_blank" rel="external">代码</a>和结构图</h3><p>因为最近出了2016 Macbook Pro是不带USB接口的，我们需要买一个TypeC/USB转换器来连接无线鼠标，蓝牙鼠标的请无视。这时我们只要借助PortAdapter来帮助WirelessMouse实现pluginUsb()，而在PortAdapter中我们用其typeC插口连接电脑的typeC端口。<br><img src="/img/java_design_patterns/adapter.png" alt=""></p>
<p>​     </p>
<h2 id="facade"><a href="#facade" class="headerlink" title="facade"></a>facade</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>在复杂系统中将多个相关的类在一个facade类中包裹起来，提供一个high-level简单易用的接口给client，隐藏其中实现细节。</p>
<h3 id="使用场景-10"><a href="#使用场景-10" class="headerlink" title="使用场景"></a>使用场景</h3><p>当系统比较复杂时，有很多相关的类有不同的方法实现，这时可以用facade将它们涵盖进去提供统一简单的接口让client使用它们。</p>
<h3 id="代码和结构图-10"><a href="#代码和结构图-10" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/facade" target="_blank" rel="external">代码</a>和结构图</h3><p>3个国家的user有各自的具体属性，通过一个facade类将3种user都包括进去并且提供统一接口给client进行访问。<br><img src="/img/java_design_patterns/facade.png" alt=""></p>
<p>​     </p>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>对一种对象提供代理来控制它。</p>
<h3 id="使用场景-11"><a href="#使用场景-11" class="headerlink" title="使用场景"></a>使用场景</h3><p>当需要对一个类添加功能时，可以用proxy代理它的接口，让client使用proxy而不是真正的类。</p>
<h3 id="代码和结构图-11"><a href="#代码和结构图-11" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/proxy" target="_blank" rel="external">代码</a>和结构图</h3><p>用ProxyUser代理RealUser来玩游戏，在proxy中限制一个user玩游戏的次数。<br><img src="/img/java_design_patterns/proxy.png" alt=""></p>
<p>​     </p>
<h1 id="Architectural模式"><a href="#Architectural模式" class="headerlink" title="Architectural模式"></a>Architectural模式</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>用于设计GUI和web frameworks，将系统分为view, controller和model三个部分。</p>
<h3 id="使用场景-12"><a href="#使用场景-12" class="headerlink" title="使用场景"></a>使用场景</h3><p>MVC常用在web框架中，比如Spring MVC。</p>
<h3 id="代码和结构图-12"><a href="#代码和结构图-12" class="headerlink" title="代码和结构图"></a><a href="https://github.com/zhanghedr/design-pattern/tree/master/src/main/java/com/zhanghedr/mvc" target="_blank" rel="external">代码</a>和结构图</h3><p>假设从数据库拿到name和email形成user对象，然后经过controller控制让user属性在view中显示出来。<br><img src="/img/java_design_patterns/mvc.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[常见 Git 命令清单与使用]]></title>
      <url>http://www.zhanghedr.com/2016/12/10/git-cheat-sheet/</url>
      <content type="html"><![CDATA[<p>Git的指令很多，每次都上stackoverflow搜答案，不如把常用的命令都记录下来。下图很好的解释了git的原理。</p>
<p><img src="/img/git_cheat_sheet/git.png" alt=""></p>
<a id="more"></a>
<p>首先解释一下这几个名词：</p>
<ul>
<li>workspace/working dir : 本地工作区</li>
<li>index/stage           : 暂存区</li>
<li>local repository      : 本地仓库</li>
<li>remote repository     : 远程仓库</li>
<li>HEAD                  : 当前分支指针</li>
<li>origin                : 默认远程</li>
<li>master                : 本地分支master</li>
<li>origin master         : 远程origin上的master</li>
<li>origin/master         : origin master的本地copy</li>
</ul>
<p>​              </p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git init                                    <span class="comment"># 初始化local repo</span></div><div class="line">git <span class="built_in">clone</span> URL                               <span class="comment"># checkout remote repo</span></div><div class="line">git <span class="built_in">clone</span> username@host:URL                 <span class="comment"># 在remote server上checkout远程仓库</span></div></pre></td></tr></table></figure>
<h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git config --list                           <span class="comment"># 查看配置，包括当前name和email</span></div><div class="line">git config [--global] user.name [name]      <span class="comment"># 设置name</span></div><div class="line">git config [--global] user.email [email]    <span class="comment"># 设置email</span></div></pre></td></tr></table></figure>
<h4 id="Add-Remove"><a href="#Add-Remove" class="headerlink" title="Add/Remove"></a>Add/Remove</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add [file1] [file2] ...                 <span class="comment"># 添加文件至index</span></div><div class="line">git add [dir]                               <span class="comment"># 添加目录至index</span></div><div class="line">git add .                                   <span class="comment"># 添加所有除了删除以外的更改文件到index</span></div><div class="line">git add -A                                  <span class="comment"># 添加所有更改文件到index</span></div><div class="line">git rm [file1] [file2] ...                  <span class="comment"># 删除working dir和index文件</span></div><div class="line">git rm --cached [file]                      <span class="comment"># 删除index文件，但保留working dir</span></div></pre></td></tr></table></figure>
<h4 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git commit -m [message]                     <span class="comment"># 提交index到local repo</span></div><div class="line">git commit -am [message]                    <span class="comment"># add + commit到local repo</span></div><div class="line">git commit --amend -m [message]             <span class="comment"># 修改上次commit</span></div></pre></td></tr></table></figure>
<h4 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git push origin master                      <span class="comment"># 上传local repo到remote master</span></div><div class="line">git push [remote] [branch]                  <span class="comment"># 上传branch到remote repo</span></div><div class="line">git push [remote] --all                     <span class="comment"># 上传所有branch到remote repo</span></div></pre></td></tr></table></figure>
<h4 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git branch                                 <span class="comment"># 列出所有local branch</span></div><div class="line">git branch -r                              <span class="comment"># 列出所有remote branch</span></div><div class="line">git branch <span class="_">-a</span>                              <span class="comment"># 列出所有local和remote branch</span></div><div class="line">git branch --merged                        <span class="comment"># 显示所有已合并到当前分支的分支</span></div><div class="line">git checkout [branch]                      <span class="comment"># working dir切换到branch </span></div><div class="line">git checkout -b [branch]                   <span class="comment"># 基于当前branch新建并切换到新branch</span></div><div class="line">git branch [branch]                        <span class="comment"># 新建branch但不切换到新branch</span></div><div class="line">git merge [branch]                         <span class="comment"># 合并branch到当前分支</span></div><div class="line">git branch <span class="_">-d</span> [branch]                     <span class="comment"># 删除branch</span></div><div class="line">git push origin --delete [branch]          <span class="comment"># 删除remote branch</span></div></pre></td></tr></table></figure>
<h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git remote                     <span class="comment"># 显示当前所有remote</span></div><div class="line">git remote show [remote]       <span class="comment"># 显示remote信息</span></div><div class="line">git remote add [remote] [URL]  <span class="comment"># 为本地添加一个新的remote</span></div><div class="line">git fetch                      <span class="comment"># 获取所有origin分支到origin/master，working dir不变</span></div><div class="line">git merge                      <span class="comment"># 合并origin/master到master，working dir改变</span></div><div class="line">git pull [remote] [branch]     <span class="comment"># 获取远程分支且合并到当前分支. git pull = git fetch + git merge</span></div><div class="line">git rebase [remote]/[branch]   <span class="comment"># 更新最新改动且重新apply本地commits到其之上</span></div></pre></td></tr></table></figure>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">log</span>                                  <span class="comment"># 显示本地提交日志，git pull后更新远程日志</span></div><div class="line">git <span class="built_in">log</span> --stat                           <span class="comment"># 显示提交日志及相关变动文件</span></div><div class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph  <span class="comment"># 图示提交日志</span></div><div class="line">git <span class="built_in">log</span> --follow [file]                  <span class="comment"># 显示文件提交日志</span></div><div class="line">git show [commit]                        <span class="comment"># 显示commit日志by commitid(缩写也可以)</span></div><div class="line">git show HEAD                            <span class="comment"># 显示HEAD commit日志</span></div><div class="line">git show origin/master                   <span class="comment"># 显示origin/master commit日志</span></div></pre></td></tr></table></figure>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git status                       <span class="comment"># 显示working dir所有修改过的文件</span></div><div class="line">git diff                         <span class="comment"># 显示working dir和index差异</span></div><div class="line">git diff --cached                <span class="comment"># 显示index和HEAD的差异</span></div><div class="line">git diff HEAD                    <span class="comment"># 显示working dir和HEAD差异</span></div><div class="line">git diff branch1 branch2         <span class="comment"># 显示两个分支区别</span></div></pre></td></tr></table></figure>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git checkout [commit]           <span class="comment"># 切换working dir到某个commit</span></div><div class="line">git checkout [commit] [file]    <span class="comment"># 恢复working dir的文件到某个commit</span></div><div class="line">git checkout [file]             <span class="comment"># 恢复index文件到working dir</span></div><div class="line">git checkout .                  <span class="comment"># 恢复所有index文件到working dir</span></div><div class="line">git reset [file]                <span class="comment"># 重置index和local repo里的文件，working dir不变</span></div><div class="line">git reset HEAD~1                <span class="comment"># 重置index和local repo到上一个commit，working dir不变</span></div><div class="line">git reset [commit]              <span class="comment"># 重置index和local repo到某个commit，working dir不变</span></div><div class="line">git reset --hard HEAD~1         <span class="comment"># 重置index, local repo和working dir到上一个commit，本地改变丢失</span></div><div class="line">git reset --hard [commit]       <span class="comment"># 重置index, local repo和working dir到某个commit，本地改变丢失</span></div><div class="line">git reset --hard origin/master  <span class="comment"># 重置index, local repo和working dir到master，本地改变丢失</span></div></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git stash                        <span class="comment"># 暂存当前修改，将working dir至为HEAD状态</span></div><div class="line">git stash list                   <span class="comment"># 查看所有暂存</span></div><div class="line">git stash pop                    <span class="comment"># 提取暂存到working dir，如有冲突需手动merge</span></div></pre></td></tr></table></figure>
<p>​                  </p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><h4 id="保留本地改动同步远程master，pull完再merge冲突"><a href="#保留本地改动同步远程master，pull完再merge冲突" class="headerlink" title="保留本地改动同步远程master，pull完再merge冲突"></a>保留本地改动同步远程master，pull完再merge冲突</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git stash; </div><div class="line">git pull --rebase origin master; </div><div class="line">git stash pop</div></pre></td></tr></table></figure>
<h4 id="撤销上次commit"><a href="#撤销上次commit" class="headerlink" title="撤销上次commit"></a>撤销上次commit</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git commit -m <span class="string">"Something wrong"</span></div><div class="line">git reset HEAD~1   <span class="comment"># HEAD~1重置index和local repo到上一次commit，最新的commit取消</span></div><div class="line">git status         <span class="comment"># undo以后再查看本地改动</span></div><div class="line">git add -A</div><div class="line">git commit -m <span class="string">"message"</span></div></pre></td></tr></table></figure>
<h4 id="修改上次commit的message和add新改动"><a href="#修改上次commit的message和add新改动" class="headerlink" title="修改上次commit的message和add新改动"></a>修改上次commit的message和add新改动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset; </div><div class="line">git commit --amend -m [message]  <span class="comment"># 注意会把working dir最新改动也加进去</span></div></pre></td></tr></table></figure>
<h4 id="显示本地和远程origin的区别"><a href="#显示本地和远程origin的区别" class="headerlink" title="显示本地和远程origin的区别"></a>显示本地和远程origin的区别</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch</div><div class="line">git diff ..origin</div></pre></td></tr></table></figure>
<h4 id="重置本地working-dir、index、local-repo到远程最新commit，抛弃本地改动"><a href="#重置本地working-dir、index、local-repo到远程最新commit，抛弃本地改动" class="headerlink" title="重置本地working dir、index、local repo到远程最新commit，抛弃本地改动"></a>重置本地working dir、index、local repo到远程最新commit，抛弃本地改动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch origin  <span class="comment"># 抓到本地</span></div><div class="line">git reset --hard origin/master  <span class="comment"># 重置到本地</span></div></pre></td></tr></table></figure>
<h4 id="回滚git-merge-branch"><a href="#回滚git-merge-branch" class="headerlink" title="回滚git merge branch"></a>回滚git merge branch</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">log</span></div><div class="line">git reset --hard [commit]</div></pre></td></tr></table></figure>
<h4 id="删除本地和remote分支"><a href="#删除本地和remote分支" class="headerlink" title="删除本地和remote分支"></a>删除本地和remote分支</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch <span class="_">-d</span> [branch]  <span class="comment"># delete local, use -D to force delete</span></div><div class="line">git push origin --delete [branch]  <span class="comment"># delete remote</span></div></pre></td></tr></table></figure>
<h4 id="Pull-Request流程"><a href="#Pull-Request流程" class="headerlink" title="Pull Request流程"></a>Pull Request流程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># fork原始仓库</span></div><div class="line">git <span class="built_in">clone</span> [URL]  <span class="comment"># 抓取fork的仓库</span></div><div class="line">git remote add upstream [URL]  <span class="comment"># 添加原仓库remote URL，如命名upstream</span></div><div class="line">git checkout -b patch  <span class="comment"># 基于当前分支新建patch分支</span></div><div class="line"><span class="comment"># 在patch下开发</span></div><div class="line">git add . &amp;&amp; git commit -m <span class="string">"update"</span> &amp;&amp; git push origin patch</div><div class="line"><span class="comment"># 如果upstream仓库有了新的改动，需要更新到我们仓库而且rebase我们的commits</span></div><div class="line">git checkout patch</div><div class="line">git fetch upstream</div><div class="line">git rebase upstream/master  <span class="comment"># 抓取upstream最新commits并且将自己patch下的commits在其之上重新apply上去</span></div><div class="line">git push <span class="_">-f</span> origin patch  <span class="comment"># 因为commit tree已经改变，需要force push</span></div><div class="line">compare and pull request patch branch <span class="keyword">in</span> github</div><div class="line"><span class="built_in">wait</span> <span class="keyword">for</span> accept/deny/request change  <span class="comment"># 注意此时如果发现有错的话依然可以继续commit，会更新到PR中</span></div><div class="line"><span class="comment"># 如果PR被接受并且merged，删除local和origin的patch分支，因为commit tree已经不同了</span></div><div class="line">git checkout master &amp;&amp; git pull upstream master</div><div class="line">git checkout -b patch-1  <span class="comment"># 基于upstream merged后的最新code开始一个新的branch</span></div></pre></td></tr></table></figure>
<h4 id="git-pull每次都提示Enter-passphrase-for-key-‘-Users-zhanghe-ssh-id-rsa’"><a href="#git-pull每次都提示Enter-passphrase-for-key-‘-Users-zhanghe-ssh-id-rsa’" class="headerlink" title="git pull每次都提示Enter passphrase for key ‘/Users/zhanghe/.ssh/id_rsa’"></a>git pull每次都提示Enter passphrase for key ‘/Users/zhanghe/.ssh/id_rsa’</h4><p>MacOS解决方法：编辑/创建~/.ssh/config，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Host *</div><div class="line">    UseKeychain yes</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建一个Hexo博客]]></title>
      <url>http://www.zhanghedr.com/2016/12/07/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>这几天弄了一个自己的博客，对于每一步的选择搜索了大量帖子，这里列出我觉得还不错的方案，NameSilo + DNSPod + Github Pages + Hexo。</p>
<a id="more"></a>
<h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><p>首先先考虑把博客托管到哪里，可以购买VPS，也可以放在云服务上如AWS和阿里云，我选择放在Github Pages。因为考虑到只是静态页面，通过Pages可以非常简单的把静态博客publish到username.github.io上，而且Github上的username.github.io repo还能作为codebase进行版本控制，非常方便。虽然已经有很多教程，但是推荐大家还是直接去<a href="https://pages.github.com/" target="_blank" rel="external">官网</a>看教程，非常简单就几步。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>大家推荐不错的有hexo, pelican, typecho, farbox, ghost等，我觉得都挺好的，毕竟博客的关键还是在于内容吧。但在选择博客架构时，有人会因为不熟悉Node.js而没有选择Hexo，我想说安装hexo是非常简单的过程，完全不知道Node.js也能用。只需要你安装Node.js和Git就能用npm来安装hexo了，这里不讨论过多细节，还是推荐大家去看<a href="https://hexo.io/docs/index.html" target="_blank" rel="external">官方文档</a>，非常快就能在本地安装好hexo。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>对于主题可能大家选择上很纠结，我用了next，虽然已经烂大街了，但是真的非常简洁漂亮，而且有3种样式可供选择，查看所有hexo官方主题点<a href="https://hexo.io/themes/" target="_blank" rel="external">这里</a>。对于主题配置，看过<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">next官方文档</a>基本上就能满足你80%需求了。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>hexo已经提供内置的部署配置，只需要配置好repo就能一键部署。当然如果你需要更灵活的方式，可以自己写个script来部署。</p>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>至此你应该就能在username.github.io看到自己的博客online了，现在可以给你的博客注册一个域名。因为听说国内的域名要备案所以我就没考虑，对于域名商看了很多推荐，大家普遍推荐的有NameSilo, GANDI, uniregistry，普遍不推荐的有Godaddy, 1&amp;1(这家虽然便宜但千万别用，血的教训)。我选了推荐最多的NameSilo，续费的价格也不会坑，注意用$1 OFF的折扣，网上一搜就有。</p>
<h2 id="DNS解析服务器"><a href="#DNS解析服务器" class="headerlink" title="DNS解析服务器"></a>DNS解析服务器</h2><p>注册域名时唯一要注意的就是在注册过程中就选你的NameServers，因为用国外的DNS解析很慢，大家普遍推荐用国内的<a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPod</a>，只需要填下面两个地址在NameServers里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">F1G1NS1.DNSPOD.NET</div><div class="line">F1G1NS2.DNSPOD.NET</div></pre></td></tr></table></figure></p>
<p>注册完成后再回到DNSPod添加你的域名，并添加CNAME记录。我这里选择www子域名作为主站，所以让顶级域名zhanghedr.com跳转到www.zhanghedr.com，然后用CNAME解析www.zhanghedr.com到username.github.io。DNSPod对于每个选项有详细解释，感觉比AWS Route 53清楚很多，至此你只需要等待一会就能看到DNS设置生效，我只等了几分钟。</p>
<h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><p>这里列出一些常见的主站_config.yml配置key</p>
<ul>
<li>title</li>
<li>description</li>
<li>author</li>
<li>language</li>
<li>theme</li>
<li>deploy</li>
</ul>
<p>常见主题_config.yml配置key</p>
<ul>
<li>favicon</li>
<li>menu</li>
<li>scheme</li>
<li>social</li>
<li>avatar</li>
<li>sidebar</li>
<li>highlight_theme</li>
<li>baidu_analytics</li>
<li>google_analytics</li>
<li>duoshuo_shortname</li>
<li>disqus_shortname</li>
<li>busuanzi_count</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>现在Github自定义域名也支持HTTPS了，所以可以很方便的在设置中添加，如果按钮是灰色，可以尝试把域名移除再重新添加，1天后certificate还没OK的话联系Github客服可以帮忙搞定。</p>
<p><img src="/img/github.png" alt="github"></p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>hexo new “blog name”</p>
<p>hexo generate</p>
<p>hexo server</p>
<p>hexo clean</p>
<p>hexo deploy</p>
<h2 id="添加版权信息"><a href="#添加版权信息" class="headerlink" title="添加版权信息"></a>添加版权信息</h2><ol>
<li>创建<code>/scripts/tail.js</code></li>
<li>创建<code>/tail.md</code> </li>
<li>更新<code>_config.yml</code></li>
</ol>
<h2 id="Even主题个性化"><a href="#Even主题个性化" class="headerlink" title="Even主题个性化"></a>Even主题个性化</h2><ul>
<li>更换<code>/even/source/favicon.ico</code></li>
<li>Optional: 安装本地搜索模块<code>npm install hexo-generator-search --save</code></li>
<li>Optional: 更新padding - <code>/even/source/css/_custom/_custom.scss</code></li>
<li>Optional: 更新<code>/even/layout/_partial/_post/copyright.swig</code></li>
</ul>
<h2 id="新设备设置"><a href="#新设备设置" class="headerlink" title="新设备设置"></a>新设备设置</h2><p>在另一台设备设置环境，<code>npm install</code>即可</p>
<p>下载主题而不是clone，从而commit主题文件</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java JDBC PreparedStatement 用法]]></title>
      <url>http://www.zhanghedr.com/2016/12/06/Java-JDBC-PreparedStatement/</url>
      <content type="html"><![CDATA[<p>在不需要ORM的场景下，用Java对MySQL进行操作时会用到PreparedStatement，它可以预载SQL语句然后再动态设置其中变量。这篇文章讲一下通常需要注意的问题和在处理大量数据时的优化。</p>
<a id="more"></a>
<h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><p>这里列出几点通常要注意的地方</p>
<ul>
<li>在循环执行PreparedStatement时，注意将只建一个instance在循环外，重复设置SQL中的变量，避免OutOfMemoryError错误</li>
<li>合理commit transactions，在需要的情况下使用conn.setAutoCommit(false)来手动commit，它的default是true，避免在每次execute时候就自动commit</li>
<li>在setAutoCommit(false)的情况下，如果抓到SQLException使用conn.rollback()来撤销当前的transaction</li>
<li>用close()关闭相关的resource，分别有ResultSet, PreparedStatement和Connection。Java 7+版本可以使用try-with-resources方式自动close</li>
</ul>
<p>简单的代码example:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">String sql = <span class="string">"..."</span>;</div><div class="line"><span class="keyword">try</span> (Connection conn = getDbConnection()) &#123;</div><div class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepareStatement(sql)) &#123;</div><div class="line">        <span class="comment">// ps.setString();</span></div><div class="line">        <span class="comment">// ps.execute();</span></div><div class="line">        conn.commit();</div><div class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">        conn.rollback();</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Batch-Update"><a href="#Batch-Update" class="headerlink" title="Batch Update"></a>Batch Update</h2><p>在执行大量数据的写入时，比如上百万条记录，这时简单的用executeUpdate()进行逐条update会变得非常慢。这里需要用PreparedStatement.executeBatch()来进行批量写入，从而减少数据库的访问次数，极大的增加速度。注意对于大量数据要批量执行batch，否则会导致OutOfMemoryError，代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> batchSize = <span class="number">1000</span>;</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (String s : names) &#123;</div><div class="line">    ps.setString(<span class="number">1</span>, s);</div><div class="line">    ps.addBatch();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (++count % batchSize == <span class="number">0</span>) &#123;</div><div class="line">        ps.executeBatch();</div><div class="line">        ps.clearBatch();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ps.executeBatch();</div></pre></td></tr></table></figure></p>
<p>注意executeBatch只能对于insert/update/delete使用，select不能使用。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文只是简单介绍了PreparedStatement用法，提高数据库速度还要看数据库本身的优化和SQL等。Java的PreparedStatement在设置变量时还是不怎么方便，还要注意?对应的顺序，但是有一些工具可以简化这个操作，大家可以搜一下。</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[2016 Thanksgiving]]></title>
      <url>http://www.zhanghedr.com/2016/12/04/2016-Thanksgiving/</url>
      <content type="html"><![CDATA[<p>今年感恩节去了一趟西部，走了一圈国家公园package环线，路线如下图，分别有Death Valley National Park, Zion National Park, Bryce Canyon National Park, Horseshoe Bend, Antelope Canyon, Grand Canyon National Park，拱门在右上角太远就没去了，发现最喜欢的还是碰巧下大雪的Bryce Canyon。<br><img src="/img/2016_thanksgiving/map.png" alt=""></p>
<a id="more"></a>
<h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><ol>
<li>Arrive Vegas</li>
<li>Dead Valley</li>
<li>Zion</li>
<li>Brcye</li>
<li>Upper/Lower Antelope Canyon, Horseshoe Bend</li>
<li>Grand Canyon South Rim</li>
<li>Back Vegas</li>
</ol>
<h2 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h2><p>这里挑出每个公园的代表照片</p>
<p><center><em>Death Valley National Park</em></center><img src="/img/2016_thanksgiving/death_valley.JPG" alt=""></p>
<p><center><em>Grand Canyon National Park</em></center><img src="/img/2016_thanksgiving/grand_canyon.JPG" alt=""></p>
<p><center><em>Antelope Canyon</em></center><img src="/img/2016_thanksgiving/antelope_canyon.jpg" alt=""></p>
<p><center><em>Horseshoe Bend</em></center><img src="/img/2016_thanksgiving/horseshoe_bend.JPG" alt=""></p>
<p><center><em>Zion National Park</em></center><img src="/img/2016_thanksgiving/zion.JPG" alt=""></p>
<p><center><em>Bryce Canyon National Park</em></center><img src="/img/2016_thanksgiving/bryce.JPG" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Life </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
